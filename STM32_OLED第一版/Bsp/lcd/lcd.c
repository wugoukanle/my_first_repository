#include <lcd.h>
#include "delay.h"
#include "stm32f10x_rcc.h"
#include <stdio.h>
#include "stdint.h"
#include "stm32f10x.h"
#include "hanzi.h"
#include <sw-key.h>
#include "Timer.h"
#include <string.h>
#include "rfid.h"
#include "Li_Power.h"
#include "usb.h"
#include "Globle_Var.h"




uint8_t KeyNum;
uint8_t g_WaitTimeOut;
uint8_t g_State;
uint8_t KeyNum;
uint8_t result=0;
uchar bijiao[39]=" ";
uint8_t flagi=0;//屏保标志
//uint8_t guanjiflag=0;//关机标志
uchar rightcode[]="1234";//正确密码
uchar code[4]="0000";
int choosetime=200;
uchar zuming[8];
uchar zuming1[2];
uchar zuming2[2];
uchar zuming3[2];
uchar zuming4[2];

extern uchar g_Buff[520];
extern UARTBUFF1  m_UB1;
extern uchar Rfid_Buff[6];

unsigned char Lock_number[4];

uchar rfidrow=0;

// unsigned char time_buff[6];

const struct  typFNT_ASCII codeASCII[] =
{
  0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18,0x00,0x00,'0',  // -0-
	0x00,0x00,0x00,0x10,0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,'1',
	0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x04,0x04,0x08,0x10,0x20,0x42,0x7E,0x00,0x00,'2',
	0x00,0x00,0x00,0x3C,0x42,0x42,0x04,0x18,0x04,0x02,0x02,0x42,0x44,0x38,0x00,0x00,'3',
	0x00,0x00,0x00,0x04,0x0C,0x14,0x24,0x24,0x44,0x44,0x7E,0x04,0x04,0x1E,0x00,0x00,'4',
	0x00,0x00,0x00,0x7E,0x40,0x40,0x40,0x58,0x64,0x02,0x02,0x42,0x44,0x38,0x00,0x00,'5',
	0x00,0x00,0x00,0x1C,0x24,0x40,0x40,0x58,0x64,0x42,0x42,0x42,0x24,0x18,0x00,0x00,'6',
	0x00,0x00,0x00,0x7E,0x44,0x44,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,'7',
	0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x24,0x18,0x24,0x42,0x42,0x42,0x3C,0x00,0x00,'8',
	0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x26,0x1A,0x02,0x02,0x24,0x38,0x00,0x00,'9',	 
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x22,0x42,0x42,0x42,0x22,0x1E,0x02,0x07,'q',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD7,0x92,0x92,0xAA,0xAA,0x44,0x44,0x00,0x00,'w',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x7E,0x40,0x40,0x42,0x3C,0x00,0x00,'e',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xEE,0x32,0x20,0x20,0x20,0x20,0xF8,0x00,0x00,'r',
	0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x7C,0x10,0x10,0x10,0x10,0x10,0x0C,0x00,0x00,'t',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x28,0x18,0x10,0x10,0xE0,'y',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC6,0x42,0x42,0x42,0x42,0x46,0x3B,0x00,0x00,'u',
	0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x70,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,'i',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,'o',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD8,0x64,0x42,0x42,0x42,0x44,0x78,0x40,0xE0,'p',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x42,0x1E,0x22,0x42,0x42,0x3F,0x00,0x00,'a',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x42,0x40,0x3C,0x02,0x42,0x7C,0x00,0x00,'s',
	0x00,0x00,0x00,0x06,0x02,0x02,0x02,0x1E,0x22,0x42,0x42,0x42,0x26,0x1B,0x00,0x00,'d',
	0x00,0x00,0x00,0x0F,0x11,0x10,0x10,0x7E,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,'f',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x44,0x44,0x38,0x40,0x3C,0x42,0x42,0x3C,'g',
	0x00,0x00,0x00,0xC0,0x40,0x40,0x40,0x5C,0x62,0x42,0x42,0x42,0x42,0xE7,0x00,0x00,'h',
	0x00,0x00,0x00,0x0C,0x0C,0x00,0x00,0x1C,0x04,0x04,0x04,0x04,0x04,0x04,0x44,0x78,'j',
	0x00,0x00,0x00,0xC0,0x40,0x40,0x40,0x4E,0x48,0x50,0x68,0x48,0x44,0xEE,0x00,0x00,'k',
	0x00,0x00,0x00,0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,'l',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x44,0x08,0x10,0x10,0x22,0x7E,0x00,0x00,'z',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6E,0x24,0x18,0x18,0x18,0x24,0x76,0x00,0x00,'x',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x22,0x40,0x40,0x40,0x22,0x1C,0x00,0x00,'c',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x28,0x10,0x10,0x00,0x00,'v',
	0x00,0x00,0x00,0xC0,0x40,0x40,0x40,0x58,0x64,0x42,0x42,0x42,0x64,0x58,0x00,0x00,'b',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xDC,0x62,0x42,0x42,0x42,0x42,0xE7,0x00,0x00,'n',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x49,0x49,0x49,0x49,0x49,0xED,0x00,0x00,'m',
	0x00,0x00,0x00,0x38,0x44,0x82,0x82,0x82,0x82,0x82,0xB2,0xCA,0x4C,0x38,0x06,0x00,'Q',
	0x00,0x00,0x00,0xD6,0x92,0x92,0x92,0x92,0xAA,0xAA,0x6C,0x44,0x44,0x44,0x00,0x00,'W',
	0x00,0x00,0x00,0xFC,0x42,0x48,0x48,0x78,0x48,0x48,0x40,0x42,0x42,0xFC,0x00,0x00,'E',
	0x00,0x00,0x00,0xFC,0x42,0x42,0x42,0x7C,0x48,0x48,0x44,0x44,0x42,0xE3,0x00,0x00,'R',
	0x00,0x00,0x00,0xFE,0x92,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x38,0x00,0x00,'T',
	0x00,0x00,0x00,0xEE,0x44,0x44,0x28,0x28,0x10,0x10,0x10,0x10,0x10,0x38,0x00,0x00,'Y',
	0x00,0x00,0x00,0xE7,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00,'U',
	0x00,0x00,0x00,0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,'I',
	0x00,0x00,0x00,0x38,0x44,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x44,0x38,0x00,0x00,'O',
	0x00,0x00,0x00,0xFC,0x42,0x42,0x42,0x42,0x7C,0x40,0x40,0x40,0x40,0xE0,0x00,0x00,'P',
	0x00,0x00,0x00,0x10,0x10,0x18,0x28,0x28,0x24,0x3C,0x44,0x42,0x42,0xE7,0x00,0x00,'A',
	0x00,0x00,0x00,0x3E,0x42,0x42,0x40,0x20,0x18,0x04,0x02,0x42,0x42,0x7C,0x00,0x00,'S',
	0x00,0x00,0x00,0xF8,0x44,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x44,0xF8,0x00,0x00,'D',
	0x00,0x00,0x00,0xFC,0x42,0x48,0x48,0x78,0x48,0x48,0x40,0x40,0x40,0xE0,0x00,0x00,'F',
	0x00,0x00,0x00,0x3C,0x44,0x44,0x80,0x80,0x80,0x8E,0x84,0x44,0x44,0x38,0x00,0x00,'G',
	0x00,0x00,0x00,0xE7,0x42,0x42,0x42,0x42,0x7E,0x42,0x42,0x42,0x42,0xE7,0x00,0x00,'H',
	0x00,0x00,0x00,0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x88,0xF0,'J',
	0x00,0x00,0x00,0xEE,0x44,0x48,0x50,0x70,0x50,0x48,0x48,0x44,0x44,0xEE,0x00,0x00,'K',
	0x00,0x00,0x00,0xE0,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x42,0xFE,0x00,0x00,'L',
	0x00,0x00,0x00,0x7E,0x84,0x04,0x08,0x08,0x10,0x20,0x20,0x42,0x42,0xFC,0x00,0x00,'Z',
	0x00,0x00,0x00,0xE7,0x42,0x24,0x24,0x18,0x18,0x18,0x24,0x24,0x42,0xE7,0x00,0x00,'X',
	0x00,0x00,0x00,0x3E,0x42,0x42,0x80,0x80,0x80,0x80,0x80,0x42,0x44,0x38,0x00,0x00,'C',
	0x00,0x00,0x00,0xE7,0x42,0x42,0x44,0x24,0x24,0x28,0x28,0x18,0x10,0x10,0x00,0x00,'V',
	0x00,0x00,0x00,0xF8,0x44,0x44,0x44,0x78,0x44,0x42,0x42,0x42,0x44,0xF8,0x00,0x00,'B',
	0x00,0x00,0x00,0xC7,0x62,0x62,0x52,0x52,0x4A,0x4A,0x4A,0x46,0x46,0xE2,0x00,0x00,'N',
	0x00,0x00,0x00,0xEE,0x6C,0x6C,0x6C,0x6C,0x54,0x54,0x54,0x54,0x54,0xD6,0x00,0x00,'M',
	0x30,0x4C,0x43,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,'~',
	0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,0x18,0x18,0x00,0x00,'!',
	0x00,0x00,0x00,0x38,0x44,0x5A,0xAA,0xAA,0xAA,0xAA,0xB4,0x42,0x44,0x38,0x00,0x00,'@',
	0x00,0x00,0x00,0x24,0x24,0x24,0xFE,0x48,0x48,0x48,0xFE,0x48,0x48,0x48,0x00,0x00,'#',
	0x00,0x00,0x10,0x38,0x54,0x54,0x50,0x30,0x18,0x14,0x14,0x54,0x54,0x38,0x10,0x10,'$',
	0x00,0x00,0x00,0x44,0xA4,0xA8,0xA8,0xA8,0x54,0x1A,0x2A,0x2A,0x2A,0x44,0x00,0x00,'%',
	0x00,0x1C,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,'^',
	0x00,0x00,0x00,0x30,0x48,0x48,0x48,0x50,0x6E,0xA4,0x94,0x88,0x89,0x76,0x00,0x00,'&',
	0x00,0x00,0x00,0x00,0x10,0x10,0xD6,0x38,0x38,0xD6,0x10,0x10,0x00,0x00,0x00,0x00,'*',
	0x00,0x02,0x04,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x08,0x08,0x04,0x02,0x00,'(',
	0x00,0x40,0x20,0x10,0x10,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x10,0x20,0x40,0x00,')',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,'_',
	0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0xFE,0x10,0x10,0x10,0x10,0x00,0x00,0x00,'+',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,'-',
	0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,'=',
	0x00,0x1E,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x1E,0x00,'[',
	0x00,0x78,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x78,0x00,']',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x20,';',
	0x00,0x60,0x60,0x20,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,';', 
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x20,0xC0,',',
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x00,0x00,'.',
	0x00,0x00,0x01,0x02,0x02,0x04,0x04,0x08,0x08,0x10,0x10,0x20,0x20,0x40,0x40,0x00,'/',
	0x00,0x03,0x04,0x04,0x04,0x04,0x04,0x08,0x04,0x04,0x04,0x04,0x04,0x04,0x03,0x00,'{',
	0x00,0x60,0x10,0x10,0x10,0x10,0x10,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x60,0x00,'}',
	0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,'|',
	0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,':',
	0x00,0x00,0x00,0x02,0x04,0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x04,0x02,0x00,0x00,'<',
	0x00,0x00,0x00,0x40,0x20,0x10,0x08,0x04,0x02,0x04,0x08,0x10,0x20,0x40,0x00,0x00,'>',
	0x00,0x00,0x00,0x3C,0x42,0x42,0x62,0x02,0x04,0x08,0x08,0x00,0x18,0x18,0x00,0x00,'?'
};


struct GB1616 Oprater[]={
	
	0x08,0x00,0x08,0x00,0x08,0x04,0x7E,0x84,0x08,0x48,0x08,0x28,0xFF,0x10,0x08,0x10,
  0x28,0x28,0x2F,0x28,0x28,0x44,0x28,0x84,0x58,0x00,0x48,0x00,0x87,0xFE,0x00,0x00,"赵",
	0x10,0x00,0x92,0xF8,0x92,0x88,0x92,0x88,0xFE,0x88,0x00,0x88,0xFE,0x88,0x02,0x88,
  0x7E,0x88,0x40,0x88,0x42,0x88,0x45,0x08,0x59,0x0A,0xE2,0x0A,0x44,0x06,0x00,0x00,"凯",
	0x1F,0xF8,0x01,0x00,0x7F,0xFE,0x41,0x04,0x1D,0x70,0x01,0x00,0x1D,0x70,0x01,0x00,
  0x3F,0xF8,0x21,0x08,0x21,0x08,0x3F,0xF8,0x21,0x08,0x21,0x08,0x3F,0xF8,0x20,0x08,"雷"
};
	
	
const uchar ASCII[]=
{
  0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18,0x00,0x00,'0',  // -0-
	0x00,0x00,0x00,0x10,0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,'1',
	0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x04,0x04,0x08,0x10,0x20,0x42,0x7E,0x00,0x00,'2',
	0x00,0x00,0x00,0x3C,0x42,0x42,0x04,0x18,0x04,0x02,0x02,0x42,0x44,0x38,0x00,0x00,'3',
	0x00,0x00,0x00,0x04,0x0C,0x14,0x24,0x24,0x44,0x44,0x7E,0x04,0x04,0x1E,0x00,0x00,'4',
	0x00,0x00,0x00,0x7E,0x40,0x40,0x40,0x58,0x64,0x02,0x02,0x42,0x44,0x38,0x00,0x00,'5',
	0x00,0x00,0x00,0x1C,0x24,0x40,0x40,0x58,0x64,0x42,0x42,0x42,0x24,0x18,0x00,0x00,'6',
	0x00,0x00,0x00,0x7E,0x44,0x44,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,'7',
	0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x24,0x18,0x24,0x42,0x42,0x42,0x3C,0x00,0x00,'8',
	0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x26,0x1A,0x02,0x02,0x24,0x38,0x00,0x00,'9',

	0x00,0x00,0x00,0x10,0x10,0x18,0x28,0x28,0x24,0x3C,0x44,0x42,0x42,0xE7,0x00,0x00,'A',
	0x00,0x00,0x00,0xF8,0x44,0x44,0x44,0x78,0x44,0x42,0x42,0x42,0x44,0xF8,0x00,0x00,'B',	
	0x00,0x00,0x00,0x3E,0x42,0x42,0x80,0x80,0x80,0x80,0x80,0x42,0x44,0x38,0x00,0x00,'C',	
	0x00,0x00,0x00,0xF8,0x44,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x44,0xF8,0x00,0x00,'D',	
	0x00,0x00,0x00,0xFC,0x42,0x48,0x48,0x78,0x48,0x48,0x40,0x42,0x42,0xFC,0x00,0x00,'E',	
	0x00,0x00,0x00,0xFC,0x42,0x48,0x48,0x78,0x48,0x48,0x40,0x40,0x40,0xE0,0x00,0x00,'F',
	
};
const uchar asc_table[] = "0123456789ABCDEF"; 

extern uint GUI_GetBKColor =White;//默认背景色（文字）	
extern uint GUI_GetColor =Black;  //默认前景色（画图，文字）
extern uchar  GUI_SetDrawMode =1;	  //1正显示 0为反白显示
extern uint posXl=0;
extern uint posYl=0;
extern uint posXr=128;
extern uint posYr=160;
//当前输入所致位置
extern uint posX=5;//0;	
extern uint posY=5;//0;
//字体格式
extern uint Sfont=0;
uchar f_CurSel;
uchar  lcd_buf2[15];
uchar  lcd_buf_batt0[] = {0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF};
uchar  lcd_buf_batt1[] = {0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF};
uchar  lcd_buf_batt2[] = {0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF};
uchar  lcd_buf_batt3[] = {0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF};
uchar  lcd_buf_signal[]= {0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF};
uchar  lcd_buf_nosignal[]= {0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF};


/*uint8_t lcd_buf_batt[]=
{
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,

0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,

0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,

0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,

0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,

0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,

0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,

0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,

0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,

0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,

0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,

0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,

0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,

0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,

0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,

0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,

};


uint8_t gImage_signal2[1024] = { 
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,
0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X00,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,
};*/

struct LCD_MODULE
 {
   uchar color[8];            //显示A0A1 A2A0 A1A2 A2B0 B0B1 B2B0 B1B2 B2A0(A为显示色，B为背景色)
  
 }LCD_PART;
 // GUI_GetBKColor=White;//默认背景色（文字）	
 // GUI_GetColor=Black;  //默认前景色（画图，文字）
 //GUI_SetDrawMode=1;	  //1正显示
 /****
  菜单选项
 *****/
#define MAX_MENU      10
const MENU_ITEM HsMenu[MAX_MENU]={   //主菜单
    {3,4,"",0},	//其结构的第0个为特别的，表示可选菜单项的起始项，和最后项，并始终将可选项放在最后
    //{0,0, "信号",ifauthorize},
    //{32,0, lcd_buf2[15],0},
    //{0,96, lcd_buf_batt[2][32],0},
    {48,48," ",0},
		{70,32,"钥匙",0},
		{144,0,"工具",tool_menu},
		{144,96,"设置",set_menu}
    };

void hs_menu(void)
{
	Choose_MenuOp1();
	return;
}
//显示授权菜单
/*void ifauthorize(void)
{
	
	if(result==0)
	{
	Choose_MenuOp2();
	}
	else
	{
	//drawrectangle();
	Choose_MenuOp3();	
	}
	return;
}*/

	
//显示工具菜单
void tool_menu(void)
{
	Choose_MenuOp4();
	return;
}
	
		
//显示设置菜单
void set_menu(void)
{
	Choose_MenuOp5();
	return;
}

const MENU_ITEM TOOLMENU[MAX_MENU]={
		{3,6,"",0},
    {144,0,"确定",0},
		{144,96,"取消",0},
    {16,16,"查看授权设备",jiancha},
    {40,32,"检查锁具",mima},
		{64,48,"采码",code_menu},
    {88,48,"关机",guanji},
    
    
		
};
const MENU_ITEM JIANCHA[MAX_MENU]={
		{4,4,"",0},
    {16,0,"设备编号",0},
    {16,96,"状态",0},
    {144,96,"取消",0},
    {144,0,"确定",0},
};
void guanji(void)
{
	Choose_MenuOp4_3();;
	return;
}
void jiancha(void)
{
	Choose_MenuOp4_4();
	return;
}
void mima(void)
{
	Choose_MenuOp4_22();;
	return;
}
MENU_ITEM MIMA[MAX_MENU]={
		{5,8,"",0},  
		{48,24,"请输入密码",0},
    {144,0,"确定",0},
    {144,48,"选择",0},
		{144,96,"返回",0},
    {80,36,"0",0},
    {80,52,"0",0},
    {80,68,"0",0},
    {80,84,"0",0},		
};
const MENU_ITEM GUANJI[MAX_MENU]={
		{2,3,"",0},
		{48,32,"是否关机",0},
    {144,0,"是",guanping},
		{144,112,"否",0}
		
};
void guanping(void)
{
	LCD_LIGHT_OFF;
	guanjiflag=1;
	return;
}
const MENU_ITEM OPEN[MAX_MENU]={
		{2,2,"",0},
    {30,36,"开锁中",0},
    {144,96,"返回",close}
    
};

void code_menu(void)
{
	Choose_MenuOp4_1();
	return;
}	
void open(void)
{
	
	
  //KEY_POWER_ON;		
	
	
	//delay_ms(5000);		
	//KEY_POWER_OFF;
	Choose_MenuOp4_2();
	return;
}
void close(void)
{
	KEY_POWER_OFF;
	Choose_MenuOp4();
	return;
}
	
const MENU_ITEM CODEMENU[MAX_MENU]={
		{3,4,"",0},
		{48,32,"读RFID",0},
		{64,16," ",0},
    {144,0,"开始",0},
		{144,96,"返回",tool_menu}
};
const MENU_ITEM SETMENU[MAX_MENU]={
		{3,5,"",0},
		{144,0,"确定",hs_menu},
		{144,96,"取消",hs_menu},
    {16,32,"屏保设置",time},
		{48,32,"亮度设置",0},
		{80,48,"关于",banben},//pfun
};
const MENU_ITEM TIME[MAX_MENU]={
		{3,5,"",0},
		{144,0,"确定",hs_menu},
		{144,96,"取消",hs_menu},
    {16,48,"10秒",0},
		{48,48,"30秒",0},
		{80,48,"50秒",0},//pfun
};
void time(void)
{
	Choose_MenuOp5_1();
	return;
}
void banben(void)
{
	Choose_MenuOp5_3();
	return;
}
const MENU_ITEM BANBEN[MAX_MENU]={
		{4,4,"",0},
		{16,24,"版本：V1.0",0},
		{48,48,"2015",0},
		{80,16,"武汉百景科技",0},
		{144,96,"返回",0}
};
const MENU_ITEM NOAUTHORIZE[MAX_MENU]={
		{2,3,"",0},
		{48,40,"未授权",0},
    {112,0,"确定",0},
		{112,96,"取消",hs_menu}
};
const MENU_ITEM AUTHORIZE[MAX_MENU]={
		{4,5,"",0},
		//{32,0,"",drawrectangle},
		{40,40,"已开锁",0},
		{60,32,"是否进入",0},
    {80,32,"巡检任务",0},
		{144,0,"是",set_task},
		{144,112,"否",0}
};
	void set_task(void)
{
	
	Choose_MenuOp3_1();
	return;
}
MENU_ITEM SETTASK[MAX_MENU]={
		{7,9,"",0},
    {40,96," ",0},
    {56,96," ",0},
    {72,96," ",0},
    {144,0,"正常",vacancy},
		{144,96,"故障",novacancy},
		{16,32,"锁1任务",0},
    {40,32,"1号开关",0},
    {56,32,"2号开关",0},
    {72,32,"3号开关",0}
};	
/*MENU_ITEM SETTASK1[MAX_MENU]={
	  //{1}
		{40,100,lcd_duihao[],0},
		{48,100,lcd_duihao[],0},
    {56,100,lcd_duihao[],0},
    {40,100,lcd_cuowu[],0},
	  {48,100,lcd_cuowu[],0},
    {56,100,lcd_cuowu[],0}
};*/
void vacancy (void)
{
	
	Choose_MenuOp3_21();
	return;
};
void novacancy (void)
{
	
	Choose_MenuOp3_22();
	return;
};
const MENU_ITEM VACANCY[MAX_MENU]={
		{3,4,"",0},
		//{32,0,"",drawrectangle},
		{40,16,"有任务未完成",0},
		{56,32,"是否结束",0},
		{144,0,"是",hs_menu},
		{144,112,"否",set_task}
};
const MENU_ITEM NOVACANCY[MAX_MENU]={
		{3,4,"",0},
		//{32,0,"",drawrectangle},
		{40,16,"任务全部完成",0},
		{56,32,"是否结束",0},
		{144,0,"是",hs_menu},
		{144,112,"否",set_task}
};

/*void drawrectangle(void)
{
	rectangle(0,0,128,40);
	return;
}*/
/***
显示本机的区位码，和前导码
void apoint_place_write(uchar s_column,uchar s_row,uchar *wr_sp,uint w_color,uint bk_color)	 .
often_show(36,56,"通信等待中..",0,0x0fff);
两种模式返回上级菜单，第一种 取消键 返回
第二种 超时返回
***/
// void this_Info(uchar para) 
// {
//   uchar i,nChar,k;
//   uchar temp_buff1[5],temp_buff2[7];
//   GUI_Clear(White);
//   for(i =0;i<2;i++)
//   temp_buff1[i] =ReadData(LOCK_TYPE); //显示需要转换为ASCII码
//   {
// 	temp_buff1[0]=0x34;
// 	temp_buff1[1]=0x56;	   //测试

//   }
//    i = temp_buff1[0];
//    nChar = temp_buff1[1];
//    temp_buff1[0] = ((i&0xf0)>>4)+0x30;
//    temp_buff1[1] =(i&0x0f)+0x30;
//    temp_buff1[2] = ((nChar&0xf0)>>4)+0x30;
//    temp_buff1[3] = (nChar&0x0f)+0x30;
//    temp_buff1[4] =0;
//   for(i =0;i<3;i++)
//   temp_buff2[i] = ReadData(LOCK_LOCAL+i);
//   {
//    	temp_buff2[0]=0x34;
// 		temp_buff2[1]=0x56;	   //测试
// 		temp_buff2[2]=0x78;
// 	

//   }
//   i = temp_buff2[0];
//   nChar = temp_buff2[1];
//   k = temp_buff2[2];
//   temp_buff2[0] = ((i&0xf0)>>4)+0x30;
//   temp_buff2[1] =(i&0x0f)+0x30;
//   temp_buff2[2] = ((nChar&0xf0)>>4)+0x30;
//   temp_buff2[3] = (nChar&0x0f)+0x30;
//   temp_buff2[4] = ((k&0xf0)>>4)+0x30;
//   temp_buff2[5] = (k&0x0f)+0x30;
//   temp_buff2[6] =0;
//   often_show(0,0,"区位码:",0,0x0fff);
//   apoint_place_write(0,17,temp_buff1,0,0xfff);
//   often_show(0,34,"前导码:",0,0x0fff);
//   apoint_place_write(0,51,temp_buff2,0,0xfff);
//   g_WaitTimeOut = 0;
//   SetTimer(TIMER_TIMEOUT,8,Do_TimeOut,THREE_MIN);   //等待操作时间
//   while( g_WaitTimeOut == 0 )
//   {
//    nChar = GetKey();
//    if(nChar ==KEYCLEAR)
//    {
// 		 GUI_Clear(White);
// 		 InsertKey(KEYINIT);
// 		 KillTimer(TIMER_TIMEOUT);
//      return;
//    }else if(nChar !=KEYNO)
//    {
//      ResetTimer(TIMER_TIMEOUT);

//    }


//   }
// 	GUI_Clear(White);
// 	InsertKey(KEYINIT);
//   KillTimer(TIMER_TIMEOUT);
// 	return;
//  	
// }
/***
显示用户的编号信息
***/
// void User_Info(uchar para) 
// {
//   uchar i,nChar;
//   uchar temp_buff1[4];	   //用户的编号为4位数据
//   uchar temp_buff2[9];
//   GUI_Clear(White);
//   for(i =0;i<4;i++)
//   temp_buff1[i] = ReadData(LOCK_LOCAL+i);
//   {
// 			temp_buff1[0]=0x01;
// 	    temp_buff1[1]=0x23;	   //测试
// 	   	temp_buff1[2]=0x45;
// 	    temp_buff1[3]=0x67;	   //测试

//   }
//   temp_buff2[0] =((temp_buff1[0]&0xf0)>>4)+0x30;
//   temp_buff2[1] =(temp_buff1[0]&0x0f)+0x30;
//   temp_buff2[2] =((temp_buff1[1]&0xf0)>>4)+0x30;
//   temp_buff2[3] =(temp_buff1[1]&0x0f)+0x30;
//   temp_buff2[4] =((temp_buff1[2]&0xf0)>>4)+0x30;
//   temp_buff2[5] =(temp_buff1[2]&0x0f)+0x30;
//   temp_buff2[6] =((temp_buff1[3]&0xf0)>>4)+0x30;
//   temp_buff2[7] =(temp_buff1[3]&0x0f)+0x30;
//   temp_buff2[8]	=0;
//   often_show(0,0,"用户编号",0,0x0fff);
//   apoint_place_write(0,17,temp_buff2,0,0xfff);
//  
//   g_WaitTimeOut = 0;
//   SetTimer(TIMER_TIMEOUT,8,Do_TimeOut,THREE_MIN);   //等待操作时间
//   while( g_WaitTimeOut == 0 )
//   {
//    nChar = GetKey();
//    if(nChar ==KEYCLEAR)
//    {

//    }else if(nChar !=KEYNO)
//    {


//    }


//   }
//   KillTimer(TIMER_TIMEOUT);

// }
/***

  for(i =0;i<4;i++)
  mid_buff[i] =Lock_number[i];
  read_time();
  for(i =0;i<6;i++)
  mid_buff[4+i]=time_buff[i];
  每一组记录为10个字节
  最近十次的操作信息
  将最后十次的操作记录读取到g_Buff缓冲区当中
***/

void ShowOneOperation(uchar temp[])
{
  uchar temp_buff1[4],temp_buff2[6],i;
  uchar Lcd_temp_buff1[9],Lcd_temp_buff2[13];
  GUI_Clear(White);
  for(i =0;i<4;i++)
  temp_buff1[i] =temp[i];
  for(i =0;i<6;i++)
  temp_buff2[i] =temp[4+i];
  {
   	temp_buff1[0]=0x01;
		temp_buff1[1]=0x23;	   //测试
    temp_buff1[2]=0x45;
		temp_buff1[3]=0x67;	   //测试

    temp_buff2[0]=0x34;
		temp_buff2[1]=0x56;	   //测试
		temp_buff2[2]=0x34;
		temp_buff2[3]=0x56;	   //测试
		temp_buff2[4]=0x34;
		temp_buff2[5]=0x56;	   //测试

 }
  Lcd_temp_buff1[0] =((temp_buff1[0]&0xf0)>>4)+0x30;
  Lcd_temp_buff1[1] =(temp_buff1[0]&0x0f)+0x30;
  Lcd_temp_buff1[2] =((temp_buff1[1]&0xf0)>>4)+0x30;
  Lcd_temp_buff1[3] =(temp_buff1[1]&0x0f)+0x30;
  Lcd_temp_buff1[4] =((temp_buff1[2]&0xf0)>>4)+0x30;
  Lcd_temp_buff1[5] =(temp_buff1[2]&0x0f)+0x30;
  Lcd_temp_buff1[6] =((temp_buff1[3]&0xf0)>>4)+0x30;
  Lcd_temp_buff1[7] =(temp_buff1[3]&0x0f)+0x30;
  Lcd_temp_buff1[8]	=0;
  Lcd_temp_buff2[0] =((temp_buff2[0]&0xf0)>>4)+0x30;
  Lcd_temp_buff2[1] =(temp_buff2[0]&0x0f)+0x30;
  Lcd_temp_buff2[2] =((temp_buff2[1]&0xf0)>>4)+0x30;
  Lcd_temp_buff2[3] =(temp_buff2[1]&0x0f)+0x30;
  Lcd_temp_buff2[4] =((temp_buff2[2]&0xf0)>>4)+0x30;
  Lcd_temp_buff2[5] =(temp_buff2[2]&0x0f)+0x30;
  Lcd_temp_buff2[6] =((temp_buff2[3]&0xf0)>>4)+0x30;
  Lcd_temp_buff2[7] =(temp_buff2[3]&0x0f)+0x30;
  Lcd_temp_buff2[8] =((temp_buff2[4]&0xf0)>>4)+0x30;
  Lcd_temp_buff2[9] =(temp_buff2[4]&0x0f)+0x30;
  Lcd_temp_buff2[10] =((temp_buff2[5]&0xf0)>>4)+0x30;
  Lcd_temp_buff2[11] =(temp_buff2[5]&0x0f)+0x30;
  Lcd_temp_buff2[12] =0;
  often_show(0,0,"表箱编号:",0,0x0fff);
  apoint_place_write(0,17,Lcd_temp_buff1,0,0xfff);
  often_show(0,34,"开箱时间:",0,0x0fff);
  apoint_place_write(0,51,Lcd_temp_buff2,0,0xfff); 

}

// void OPeration_Info(uchar para) 
// {
//   uchar i,idx,Lcd_temp[10],nChar;
//   idx =0;
//   InsertKey(KEYINIT);
//   g_WaitTimeOut = 0;
//   SetTimer(TIMER_TIMEOUT,8,Do_TimeOut,THREE_MIN);   //等待操作时间
//   while( g_WaitTimeOut == 0 )
//   {
//    nChar = GetKey();
//    if(nChar ==KEYINIT)
//    {
// 		 for(i =0;i<10;i++)
// 		 Lcd_temp[i] =g_Buff[idx+i];
// 		 ShowOneOperation(Lcd_temp);

//    }else if(nChar ==KEYDOWN)
//    {
//     
//      idx =idx+10;
// 		 if(idx >100)
// 		 idx =0;
// 		 for(i =0;i<10;i++)
// 		 Lcd_temp[i] =g_Buff[idx+i];
// 		 ShowOneOperation(Lcd_temp);

//    }else if(nChar ==KEYUP)
//    {
//      if(idx >0)
//      idx =idx-10;
// 		 else
// 		 idx =90;
// 		 for(i =0;i<10;i++)
// 		 Lcd_temp[i] =g_Buff[idx+i];
// 		 ShowOneOperation(Lcd_temp);

//    }
//    if(nChar ==KEYCLEAR)
//    {

//    }


//   }

// }
/***
显示存储空间信息
***/
// void Save_Info(uchar para) 
// {
//   uchar i,nChar,k;
//   uchar temp_buff1[5],temp_buff2[7];
//   GUI_Clear(White);
//   for(i =0;i<2;i++)
//   temp_buff1[i] =ReadData(LOCK_TYPE);
//   {
// 		temp_buff1[0]=0x34;
//     	temp_buff1[1]=0x56;	   //测试
//   }
//    i = temp_buff1[0];
//    nChar = temp_buff1[1];
//    temp_buff1[0] = ((i&0xf0)>>4)+0x30;
//    temp_buff1[1] =(i&0x0f)+0x30;
//    temp_buff1[2] = ((nChar&0xf0)>>4)+0x30;
//    temp_buff1[3] = (nChar&0x0f)+0x30;
//    temp_buff1[4] =0;
//   for(i =0;i<3;i++)
//   temp_buff2[i] = ReadData(LOCK_LOCAL+i);
//   {
// 		temp_buff2[0]=0x34;
// 	    temp_buff2[1]=0x56;	   //测试
// 		temp_buff2[2]=0x34;
// 	

//   }
//      i = temp_buff2[0];
//    nChar = temp_buff2[1];
//    k = temp_buff2[2];
//    temp_buff2[0] = ((i&0xf0)>>4)+0x30;
//    temp_buff2[1] =(i&0x0f)+0x30;
//    temp_buff2[2] = ((nChar&0xf0)>>4)+0x30;
//    temp_buff2[3] = (nChar&0x0f)+0x30;
//    temp_buff2[4] = ((k&0xf0)>>4)+0x30;
//    temp_buff2[5] = (k&0x0f)+0x30;
//    temp_buff2[6] =0;
//   often_show(0,0,"已存储用户",0,0x0fff);
//   apoint_place_write(0,17,temp_buff1,0,0xfff);
//   often_show(0,34,"剩余存储空间",0,0x0fff);
//   apoint_place_write(0,51,temp_buff2,0,0xfff);
//   g_WaitTimeOut = 0;
//   SetTimer(TIMER_TIMEOUT,8,Do_TimeOut,THREE_MIN);   //等待操作时间
//   while( g_WaitTimeOut == 0 )
//   {
//    nChar = GetKey();
//    if(nChar ==KEYCLEAR)
//    {

//    }else if(nChar !=KEYNO)
//    {


//    }


//   }
//   KillTimer(TIMER_TIMEOUT);  
//   
// }



void ShowHsMenu(void) //主菜单显示
{
    uchar idx;
   //Lcd_Show(1,0, "功能选择菜单");
   // WATCHDOG_CLEAR;                   //清除看门狗
    for (idx=5;idx<7;idx++)
    {
       if (idx==f_CurSel)
           Lcd_ShowN(HsMenu[idx].row,HsMenu[idx].col,(uchar*)HsMenu[idx].Name);		//会将选中的行反白显示
       else
           Lcd_Show(HsMenu[idx].row,HsMenu[idx].col,(uchar*)HsMenu[idx].Name);		//未选中的行正常显示
    }
		//循环完之后所有菜单项全部显示
}

void ShowMenu(const MENU_ITEM *Menu) //主菜单显示
{
    uchar idx;
   //Lcd_Show(1,0, "功能选择菜单");
   // WATCHDOG_CLEAR;                   //清除看门狗
    for (idx=1;idx<=Menu[0].col;idx++)
    {
       if (idx==f_CurSel)
           Lcd_ShowN(Menu[idx].row,Menu[idx].col,(uchar*)Menu[idx].Name);		//会将选中的行反白显示
       else
           Lcd_Show(Menu[idx].row,Menu[idx].col,(uchar*)Menu[idx].Name);		//未选中的行正常显示
    }
		//循环完之后所有菜单项全部显示
}

/**
 	apoint_place_write(0,1,lcd_buf,0,0xfff);  //年月日
	apoint_place_write(0,17,lcd_buf1,0,0xfff);  //时分秒
反白显示,函数还没有写完整
**/
void  Lcd_ShowN(uchar row, uchar col, uchar *str)
{
   GUI_SetDrawMode =0;  //反白显示
   apoint_place_write(col,row,str,0,0xfff);
   GUI_SetDrawMode =1;

}

void Lcd_Show(uchar row, uchar col, uchar *str)
{
   apoint_place_write(col,row,(uchar*)str,0,0xfff);
}



/*显示界面的入口*/
void Choose_MenuOp(void)
{
  uchar nChar;
  GUI_Clear(White);
  ResetKey();			//Key_Num =KEYNO
  f_CurSel =0;
  g_WaitTimeOut = 0;
  //SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
  // while( g_WaitTimeOut == 0 )  //超时等待
	//void InsertKey(uchar nChar){ Key_Num =nChar;}
  InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
  while(1)
  {
		nChar = GetKey();   //读取按键缓冲区
		if(nChar ==KEYINIT)
		{
			Lcd_Clear(0);	    //清屏
			ShowHsMenu();		//显示菜单
			InsertKey(KEYNO);		//Key_Num =nChar;
		}
		else if(nChar == KEYUP)	//上翻	++
		{
				 
				ResetTimer(TIMER_TIMEOUT);		//还没实现
				if (f_CurSel< MAX_MENU - 1)
						++f_CurSel;
				else
						f_CurSel = 0;
				Lcd_Clear(0);
				ShowHsMenu();		//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
				InsertKey(KEYNO); 

		}else if(nChar ==KEYDOWN)//下翻	--
		{
					
					ResetTimer(TIMER_TIMEOUT);
					if (f_CurSel>0)
							--f_CurSel;
					else
							f_CurSel =  MAX_MENU - 1;
					Lcd_Clear(0);
					ShowHsMenu();
					InsertKey(KEYNO); 

		}else if(nChar ==KEYSURE) //确定
		{
					 
					KillTimer(TIMER_TIMEOUT);
					g_WaitTimeOut = 0;
					Lcd_Clear(0);
					HsMenu[f_CurSel].pFunc(0);		//f_CurSel表示当前的行
					InsertKey(KEYNO); 

		}else if( nChar ==KEYCLEAR)//取消
		{
					KeyNum =KEYNO;
					Lcd_Clear(0);
					g_State = ST_IDLE;
					InsertKey(KEYNO);
					break;

		}
  }
  KillTimer(TIMER_TIMEOUT);
  g_State =ST_IDLE;
  return;
} 

/*显示界面的入口*/
void Choose_MenuOp1(void)
{
  uchar flag=0,j=0,nChar,temp_f_CurSel,flagshijian=0,keycode;
  int i=0;
	//GUI_Clear(White);
  //ResetKey();			//Key_Num =KEYNO
  f_CurSel =HsMenu[0].row;
//   g_WaitTimeOut = 0;
//   SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
//   while( g_WaitTimeOut == 0 )  //超时等待

	delay_ms(100);
	Lcd_Clear(0);	    //清屏
	ShowMenu(HsMenu);
	keycode=ReadData(KEY_ENCODE);
	DisplayNumber(68, 70, 0, keycode);
	GUI_DisphzAt(zuming1,32,48);
	GUI_DisphzAt(zuming2,48,48);
	GUI_DisphzAt(zuming3,64,48);
	GUI_DisphzAt(zuming4,80,48);
	//apoint_place_write(32,0,lcd_buf2,0,0x0fff);
	//show_picture1(0,0,31,15,lcd_buf_batt);
 	//show_picture1(96,0,127,15,gImage_signal2);
	    if(Power_Cheak() ==0)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt0);	
					}
			else if(Power_Cheak() ==1)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt3);
					}
			     else if(Power_Cheak() ==2)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt1);	
					}
			          else if(Power_Cheak() ==3)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt2);	
					}
					
 			 if((USB_CHEAK&(GPIO_Pin_12))!=0)  //USB_CHEAK ==(GPIO_Pin_12)
			{
				show_picture1(96,0,127,15,lcd_buf_signal);
      }
			else if((USB_CHEAK&(GPIO_Pin_12))==0)
			{
				show_picture1(96,0,127,15,lcd_buf_nosignal);
      }
			GUI_Clear2(31,0,95,15,White);
			Main_Lcd_Show2();
	    //apoint_place_write(32,0,lcd_buf2,0,0x0fff);
			//显示菜单
	//void InsertKey(uchar nChar){ Key_Num =nChar;}	
  //InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
	
  while(1)
  {
		Init_KeyNumuber();			
		nChar = GetKey();
		//apoint_place_write(32,0,lcd_buf2,0,0x0fff);
			if(guanjiflag==1)
		{
			break;
    }
		else{
		if(result==1)
		{
			delay_ms(3000);
			Choose_MenuOp3();	
			Lcd_Clear(0);	    //清屏
	    ShowMenu(HsMenu);
			DisplayNumber(64, 70, 0, keycode);
			//apoint_place_write(32,0,lcd_buf2,0,0x0fff);
	    //show_picture1(0,0,31,15,lcd_buf_batt);
 	    //show_picture1(96,0,127,15,gImage_signal2);
			if(Power_Cheak() ==0)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt0);	
					}
			else if(Power_Cheak() ==1)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt3);
					}
			     else if(Power_Cheak() ==2)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt1);	
					}
			          else if(Power_Cheak() ==3)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt2);	
					}
			if((USB_CHEAK&(GPIO_Pin_12))!=0)  //USB_CHEAK ==(GPIO_Pin_12)
			{
				show_picture1(96,0,127,15,lcd_buf_signal);
      }
			else if ((USB_CHEAK&(GPIO_Pin_12))==0)
			{
				show_picture1(96,0,127,15,lcd_buf_nosignal);
      }
			GUI_Clear2(31,0,95,15,White);
			Main_Lcd_Show2();
		}
		if(nChar ==KEYINIT)  //超时关屏
		{
			i++;
			//Delay(100);
			delay_ms(100);
			      if(Power_Cheak() ==0)
								{
								show_picture1(0,0,31,15,lcd_buf_batt0);	
								}
						else if(Power_Cheak() ==1)
								{
								show_picture1(0,0,31,15,lcd_buf_batt3);
								}
								 else if(Power_Cheak() ==2)
								{
								show_picture1(0,0,31,15,lcd_buf_batt1);	
								}
											else if(Power_Cheak() ==3)
								{
								show_picture1(0,0,31,15,lcd_buf_batt2);	
								}
						if((USB_CHEAK&(GPIO_Pin_12))!=0)  //USB_CHEAK ==(GPIO_Pin_12)
						{
							show_picture1(96,0,127,15,lcd_buf_signal);
						}
						else if ((USB_CHEAK&(GPIO_Pin_12))==0)
						{
							show_picture1(96,0,127,15,lcd_buf_nosignal);
						}
						if(flagshijian==10)
						{
						GUI_Clear2(31,0,95,15,White);
						Main_Lcd_Show2();
						flagshijian=0;
						}
		  if(i>=choosetime)//按下超过10秒钟
		  {
		  	LCD_LIGHT_OFF;
			  flag=1;
		  	i=0;
		  }
		}
		if(flag==1&&(nChar ==KEYCLEAR||nChar ==KEYSURE||nChar ==KEYDOWN||nChar == KEYUP))
		{
			LCD_LIGHT_ON;
			flag=0;
			delay_ms(1000);
			nChar =KEYINIT;
    }
	 if(flag==0&&nChar == KEYUP)	//上翻	++
		{
				 i=0;
				//ResetTimer(TIMER_TIMEOUT);		//还没实现
				if (f_CurSel>HsMenu[0].row)		//HsMenu[0].col是最大
						--f_CurSel;
				else if(f_CurSel==HsMenu[0].row) //HsMenu[0].row是最小
						f_CurSel = HsMenu[0].col;		//HsMenu[0].row是最小
				Lcd_Clear(0);
				ShowMenu(HsMenu);		//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
				DisplayNumber(68, 70, 0, keycode);
				GUI_DisphzAt(zuming1,32,48);
				GUI_DisphzAt(zuming2,48,48);
				GUI_DisphzAt(zuming3,64,48);
				GUI_DisphzAt(zuming4,80,48);
				if(Power_Cheak() ==0)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt0);	
					}
			  else if(Power_Cheak() ==1)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt3);
					}
			     else if(Power_Cheak() ==2)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt1);	
					}
			          else if(Power_Cheak() ==3)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt2);	
					}
			if((USB_CHEAK&(GPIO_Pin_12))!=0)  //USB_CHEAK ==(GPIO_Pin_12)
			{
				show_picture1(96,0,127,15,lcd_buf_signal);
      }
			else if ((USB_CHEAK&(GPIO_Pin_12))==0)
			{
				show_picture1(96,0,127,15,lcd_buf_nosignal);
      }
				GUI_Clear2(31,0,95,15,White);
				Main_Lcd_Show2();
				//apoint_place_write(32,0,lcd_buf2,0,0x0fff);	
				//show_picture1(0,0,31,15,lcd_buf_batt);
        //show_picture1(96,0,127,15,gImage_signal2);
				
				Init_KeyNumuber();

		}
 		 if(flag==0&&nChar ==KEYDOWN)//下翻	--
 		{
 					i=0;
 					if (f_CurSel<HsMenu[0].col)		//HsMenu[0].col是最大
						++f_CurSel;
				  else if(f_CurSel==HsMenu[0].col) //HsMenu[0].row是最小
						f_CurSel = HsMenu[0].row;	
 					Lcd_Clear(0);
 					ShowMenu(HsMenu);
 					DisplayNumber(68, 70, 0, keycode);
				  GUI_DisphzAt(zuming1,32,48);
					GUI_DisphzAt(zuming2,48,48);
					GUI_DisphzAt(zuming3,64,48);
					GUI_DisphzAt(zuming4,80,48);
					if(Power_Cheak() ==0)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt0);	
					}
			  else if(Power_Cheak() ==1)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt3);
					}
			     else if(Power_Cheak() ==2)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt1);	
					}
			          else if(Power_Cheak() ==3)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt2);	
					}
			if((USB_CHEAK&(GPIO_Pin_12))!=0)  //USB_CHEAK ==(GPIO_Pin_12)
			{
				show_picture1(96,0,127,15,lcd_buf_signal);
      }
			else if ((USB_CHEAK&(GPIO_Pin_12))==0)
			{
				show_picture1(96,0,127,15,lcd_buf_nosignal);
      }
				GUI_Clear2(31,0,95,15,White);
				Main_Lcd_Show2();
 				Init_KeyNumuber();
// 					delay_ms(1);
//           GPIOC->IDR= GPIO_Pin_8;

 		}
		if(flag==0&&nChar ==KEYSURE) //确定
		{
					i=0;
					Lcd_Clear(0);
					temp_f_CurSel=f_CurSel;
					HsMenu[f_CurSel].pFunc(0);		//f_CurSel表示当前的行
					f_CurSel=temp_f_CurSel;				
					ShowMenu(HsMenu);	
			    DisplayNumber(68, 70, 0, keycode);
			    GUI_DisphzAt(zuming1,32,48);
					GUI_DisphzAt(zuming2,48,48);
					GUI_DisphzAt(zuming3,64,48);
					GUI_DisphzAt(zuming4,80,48);
			if(Power_Cheak() ==0)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt0);	
					}
			else if(Power_Cheak() ==1)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt3);
					}
			     else if(Power_Cheak() ==2)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt1);	
					}
			          else if(Power_Cheak() ==3)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt2);	
					}
			if((USB_CHEAK&(GPIO_Pin_12))!=0)  //USB_CHEAK ==(GPIO_Pin_12)
			{
				show_picture1(96,0,127,15,lcd_buf_signal);
      }
			else if ((USB_CHEAK&(GPIO_Pin_12))==0)
			{
				show_picture1(96,0,127,15,lcd_buf_nosignal);
      }
			GUI_Clear2(31,0,95,15,White);
			Main_Lcd_Show2();
	     //apoint_place_write(32,0,lcd_buf2,0,0x0fff);
			    Init_KeyNumuber();
			 //  break;

		} 
		if( flag==0&&nChar ==KEYCLEAR)//取消
		{
			    i=0;
			    j++;
					//KeyNum =KEYNO;
			    delay_ms(100);
		   

		}
		      if(j>=30)//按下超过3秒钟
		      {
		  	    j=0;
					  temp_f_CurSel=f_CurSel;
					  Choose_MenuOp4_3();
						//if(f_CurSel==3)	
						//break;
						f_CurSel=temp_f_CurSel;				
						ShowMenu(HsMenu);	
						DisplayNumber(68, 70, 0, keycode);
						GUI_DisphzAt(zuming1,32,48);
						GUI_DisphzAt(zuming2,48,48);
						GUI_DisphzAt(zuming3,64,48);
						GUI_DisphzAt(zuming4,80,48);
						if(Power_Cheak() ==0)
								{
								show_picture1(0,0,31,15,lcd_buf_batt0);	
								}
						else if(Power_Cheak() ==1)
								{
								show_picture1(0,0,31,15,lcd_buf_batt3);
								}
								 else if(Power_Cheak() ==2)
								{
								show_picture1(0,0,31,15,lcd_buf_batt1);	
								}
											else if(Power_Cheak() ==3)
								{
								show_picture1(0,0,31,15,lcd_buf_batt2);	
								}
						if((USB_CHEAK&(GPIO_Pin_12))!=0)  //USB_CHEAK ==(GPIO_Pin_12)
						{
							show_picture1(96,0,127,15,lcd_buf_signal);
						}
						else if ((USB_CHEAK&(GPIO_Pin_12))==0)
						{
							show_picture1(96,0,127,15,lcd_buf_nosignal);
						}
						GUI_Clear2(31,0,95,15,White);
						Main_Lcd_Show2();
		      }
					else if (nChar !=KEYCLEAR&&j>0&&j<20)
					{
					Lcd_Clear(0);
					g_State = ST_IDLE;
					ResetKey();
				  break;
					}   

	}
	++flagshijian;
  }
  g_State =ST_IDLE;
  return;
}
/*显示界面的授权*/
/*void Choose_MenuOp2(void)
{
  uchar nChar;
  GUI_Clear(White);
  ResetKey();			//Key_Num =KEYNO
  f_CurSel =NOAUTHORIZE[0].row;
  g_WaitTimeOut = 0;
  SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
  while( g_WaitTimeOut == 0 )  //超时等待
	//void InsertKey(uchar nChar){ Key_Num =nChar;}
  InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
  while(1)
  {
		nChar = GetKey();   //读取按键缓冲区
		if(nChar ==KEYINIT)
		{
			Lcd_Clear(0);	    //清屏
			ShowMenu(NOAUTHORIZE);		//显示菜单
			//apoint_place_write(32,0,lcd_buf2,0,0x0fff);	
			InsertKey(KEYNO);		//Key_Num =nChar;
		}
		else if(nChar == KEYUP)	//上翻	++
		{
				 
				ResetTimer(TIMER_TIMEOUT);		//还没实现
				if (f_CurSel<=NOAUTHORIZE[0].col)
						++f_CurSel;
				else
						f_CurSel = NOAUTHORIZE[0].row;
				Lcd_Clear(0);
				ShowMenu(NOAUTHORIZE);		//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
				//apoint_place_write(32,0,lcd_buf2,0,0x0fff);	
				InsertKey(KEYNO); 

		}else if(nChar ==KEYDOWN)//下翻	--
		{
					
					ResetTimer(TIMER_TIMEOUT);
					if (f_CurSel>NOAUTHORIZE[0].row)
							--f_CurSel;
					else
							f_CurSel =  NOAUTHORIZE[0].col;
					Lcd_Clear(0);
					ShowMenu(NOAUTHORIZE);
					//apoint_place_write(32,0,lcd_buf2,0,0x0fff);	
					InsertKey(KEYNO); 

		}else if(nChar ==KEYSURE) //确定
		{
					 
					KillTimer(TIMER_TIMEOUT);
					g_WaitTimeOut = 0;
					Lcd_Clear(0);
					NOAUTHORIZE[f_CurSel].pFunc(0);		//f_CurSel表示当前的行
					InsertKey(KEYNO); 

		}else if( nChar ==KEYCLEAR)//取消
		{
					//KeyNum =KEYNO;
					Lcd_Clear(0);
					g_State = ST_IDLE;
					ResetKey();
					break;

		}
  }
  KillTimer(TIMER_TIMEOUT);
  g_State =ST_IDLE;
  return;
}*/
/*显示界面的入口*/
void Choose_MenuOp3(void)
{
  uchar flag=0,j=0,nChar,temp_f_CurSel;
	int i=0;
  //GUI_Clear(White);
  //ResetKey();			//Key_Num =KEYNO
  f_CurSel =AUTHORIZE[0].row;
  //g_WaitTimeOut = 0;
  //SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
  //while( g_WaitTimeOut == 0 )  //超时等待
	//void InsertKey(uchar nChar){ Key_Num =nChar;}
  //InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
	delay_ms(100);
	Lcd_Clear(0);	 			//清屏
	//drawrectangle();
	ShowMenu(AUTHORIZE);		//显示菜单
  while(1)
  {
		Init_KeyNumuber();			
		nChar = GetKey();		//读取按键缓冲区
		if(guanjiflag==1)
		{
			break;
    }
		else{
			if(nChar ==KEYINIT)  //超时关屏
		{
			i++;
			//Delay(100);
			delay_ms(100);
		  if(i>=choosetime)//按下超过10秒钟
		  {
		  	LCD_LIGHT_OFF;
			  flag=1;
		  	i=0;
		  }
		}
		if(flag==1&&(nChar ==KEYCLEAR||nChar ==KEYSURE||nChar ==KEYDOWN||nChar == KEYUP))
		{
			LCD_LIGHT_ON;
			flag=0;
			delay_ms(1000);
			nChar =KEYINIT;
    }
	 if(nChar == KEYUP)	//上翻	++
		{
				 i=0;
			   j=0;
				ResetTimer(TIMER_TIMEOUT);		//还没实现
				if (f_CurSel>AUTHORIZE[0].row)		//HsMenu[0].col是最大
						--f_CurSel;
				else if(f_CurSel==AUTHORIZE[0].row) //HsMenu[0].row是最小
						f_CurSel = AUTHORIZE[0].col;		
				Lcd_Clear(0);
				ShowMenu(AUTHORIZE);	
				//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
				//apoint_place_write(32,0,lcd_buf2,0,0x0fff);	
				Init_KeyNumuber();	

		}if(nChar ==KEYDOWN)//下翻	--
		{
					i=0;
		      j=0;
					if (f_CurSel<AUTHORIZE[0].col)
							++f_CurSel;
					else
							f_CurSel =  AUTHORIZE[0].row;
					Lcd_Clear(0);
					ShowMenu(AUTHORIZE);
					//apoint_place_write(32,0,lcd_buf2,0,0x0fff);	
					Init_KeyNumuber();

		}
		 if(nChar ==KEYSURE) //确定
		{
					i=0; 
			    j=0;
					//KillTimer(TIMER_TIMEOUT);
					g_WaitTimeOut = 0;
					Lcd_Clear(0);
					temp_f_CurSel=f_CurSel;
					if(f_CurSel==5)
						break;
					else if(f_CurSel==4)
					AUTHORIZE[f_CurSel].pFunc(0);		//f_CurSel表示当前的行
					f_CurSel=temp_f_CurSel;				
					Init_KeyNumuber();
			    ShowMenu(AUTHORIZE);	
			    //show_picture1(0,0,31,15,lcd_buf_batt);
          //show_picture1(96,0,127,15,gImage_signal2);
	        //apoint_place_write(32,0,lcd_buf2,0,0x0fff);
			    
			 //  break;

		}
		if( flag==0&&nChar ==KEYCLEAR)//取消
		{
			    i=0;
			    j++;
					//KeyNum =KEYNO;
			    delay_ms(100);
		   

		}
		if(j>=30)//按下超过3秒钟
		      {
		  	    j=0;
					  temp_f_CurSel=f_CurSel;
					  Choose_MenuOp4_3();
						//if(f_CurSel==2)	
						//break;
						f_CurSel=temp_f_CurSel;				
						ShowMenu(AUTHORIZE);	
		      }
		else if (nChar !=KEYCLEAR&&j>0&&j<20)
					{
					j=0;
					Lcd_Clear(0);
					g_State = ST_IDLE;
					ResetKey();
				  break;
					} 
		  }
}
  //KillTimer(TIMER_TIMEOUT);
  g_State =ST_IDLE;
  return;
}
/*显示界面的入口*/
void Choose_MenuOp3_1(void)
{
  uchar flag=0,j=0,nChar,temp_f_CurSel;
  int i=0;
  //GUI_Clear(White);
  //ResetKey();			//Key_Num =KEYNO
  f_CurSel =SETTASK[0].row;
	delay_ms(100);
	Lcd_Clear(0);	    //清屏
	ShowMenu(SETTASK);
	//j=f_CurSel;
  //g_WaitTimeOut = 0;
  //SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
  // while( g_WaitTimeOut == 0 )  //超时等待
	//void InsertKey(uchar nChar){ Key_Num =nChar;}
  //InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
  while(1)
  {
		Init_KeyNumuber();			
		nChar = GetKey();   //读取按键缓冲区 
		if(guanjiflag==1)
		{
			break;
    }
		else{
    		if(nChar ==KEYINIT)  //超时关屏
		{
			i++;
			//Delay(100);
			delay_ms(100);
		  if(i>=choosetime)//按下超过10秒钟
		  {
		  	LCD_LIGHT_OFF;
			  flag=1;
		  	i=0;
		  }
		}
		if(flag==1&&(nChar ==KEYCLEAR||nChar ==KEYSURE||nChar ==KEYDOWN||nChar == KEYUP))
		{
			LCD_LIGHT_ON;
			flag=0;
			delay_ms(1000);
			nChar =KEYINIT;
    }
	 if(nChar == KEYUP)	//上翻	++
		{
				i=0;
			  j=0;
				//ResetTimer(TIMER_TIMEOUT);		//还没实现
				if (f_CurSel>SETTASK[0].row)		//HsMenu[0].col是最大
						--f_CurSel;
				else if(f_CurSel==SETTASK[0].row) //HsMenu[0].row是最小
						f_CurSel = SETTASK[0].col;		
				Lcd_Clear(0);
				ShowMenu(SETTASK);		//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
				//InsertKey(KEYNO); 
        Init_KeyNumuber();
		}
		 if(nChar ==KEYDOWN)//下翻	--
		{
					i=0;
		      j=0;
					//ResetTimer(TIMER_TIMEOUT);
					if (f_CurSel<SETTASK[0].col)
							++f_CurSel;
					else
							f_CurSel =  SETTASK[0].row;
					Lcd_Clear(0);
					ShowMenu(SETTASK);
					Init_KeyNumuber(); 

		}
	 if(nChar ==KEYSURE) //确定
		{
			//if(f_CurSel<5 && f_CurSel>1)
			//{
					//KillTimer(TIMER_TIMEOUT);
					//g_WaitTimeOut = 0;
					//SETTASK[f_CurSel].pFunc(0);		//f_CurSel表示当前的行
			    i=0;
		      j=0;
			  	if (strcmp(SETTASK[f_CurSel-6].Name,bijiao))
					{ 
						
						Lcd_Clear(0);
					 //SETTASK[f_CurSel+3].Name=SETTASK1[f_CurSel-1].Name;
						strcpy((char*)SETTASK[f_CurSel-6].Name,"Y");

						ShowMenu(SETTASK);
			    //apoint_place_write(f_CurSel+38+7*(f_CurSel-2),100,lcd_duihao,0,0x0fff);
				 }
				else 
				{
					flagi++;
					Lcd_Clear(0);
					strcpy((char*)SETTASK[f_CurSel-6].Name,"Y");
					ShowMenu(SETTASK);
				}
        
			//}
			
				 Init_KeyNumuber();

		}
		if( flag==0&&nChar ==KEYCLEAR)//取消
		{
			    i=0;
			    j++;
					//KeyNum =KEYNO;
			    delay_ms(100);
		   

		}
		if(j>=30)//按下超过3秒钟
		      {
		  	    j=0;
					  temp_f_CurSel=f_CurSel;
					  Choose_MenuOp4_3();
						//if(f_CurSel==2)	
						//break;
						f_CurSel=temp_f_CurSel;				
						ShowMenu(AUTHORIZE);	
		      }
		else if (nChar !=KEYCLEAR&&j>0&&j<20)
		{			
			//if(f_CurSel<5 && f_CurSel>1)
			//{
			    //KillTimer(TIMER_TIMEOUT);
					//g_WaitTimeOut = 0;
					//Lcd_Clear(0);
			  i=0;
		    j=0;
				if (strcmp(SETTASK[f_CurSel-6].Name,bijiao))
				{
					Lcd_Clear(0);
					strcpy((char *)SETTASK[f_CurSel-6].Name,"N");
					ShowMenu(SETTASK);
			    //apoint_place_write(f_CurSel+38+7*(f_CurSel-2),100,lcd_cuowu,0,0x0fff);
				}
				else
				{
					flagi++; 
					Lcd_Clear(0);
					strcpy((char *)SETTASK[f_CurSel-6].Name,"N");
					ShowMenu(SETTASK);
        }
				Init_KeyNumuber();
			}
				//g_State = ST_IDLE;
					//InsertKey(KEYNO);
					//break;

		//}
		if(f_CurSel==9&&strcmp(SETTASK[3].Name,bijiao))
			{
				if(flagi>=3)
				{ 
					SETTASK[5].pFunc(0);
					if(f_CurSel==3)
					{break;}
					f_CurSel=7;
					ShowMenu(SETTASK);
					Lcd_Clear(0);
        }
				else if(flagi<3&&flagi>0)
				{ 
					//temp_f_CurSel=f_CurSel;
					SETTASK[4].pFunc(0);
					if(f_CurSel==3)
					{break;}
					f_CurSel=7;
					ShowMenu(SETTASK);
					Init_KeyNumuber();
        }
      }
		}
  }
  //KillTimer(TIMER_TIMEOUT);
  g_State =ST_IDLE;
  return;
}
void Choose_MenuOp3_21(void)
{
  uchar flag=0,j=0,nChar,temp_f_CurSel;
	int i=0;
  //GUI_Clear(White);
  //ResetKey();			//Key_Num =KEYNO
  f_CurSel =VACANCY[0].row;
  //g_WaitTimeOut = 0;
  //SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
  // while( g_WaitTimeOut == 0 )  //超时等待
	//void InsertKey(uchar nChar){ Key_Num =nChar;}
  //InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
	delay_ms(100);
	Lcd_Clear(0);	    //清屏
	ShowMenu(VACANCY);
  while(1)
  {
		Init_KeyNumuber();			
		nChar = GetKey();   //读取按键缓冲区
		if(guanjiflag==1)
		{
			break;
    }
		else{
    		if(nChar ==KEYINIT)  //超时关屏即屏保
		{
			i++;
			//Delay(100);
			delay_ms(100);
		  if(i>=choosetime)//按下超过10秒钟
		  {
		  	LCD_LIGHT_OFF;
			  flag=1;
		  	i=0;
		  }
		}
		if(flag==1&&(nChar ==KEYCLEAR||nChar ==KEYSURE||nChar ==KEYDOWN||nChar == KEYUP))
		{
			LCD_LIGHT_ON;
			flag=0;
			delay_ms(1000);
			nChar =KEYINIT;
    }
		if(nChar == KEYUP)	//上翻	++
		{
				i=0;
			  j=0; 
				ResetTimer(TIMER_TIMEOUT);		//还没实现
				if (f_CurSel>VACANCY[0].row)		//HsMenu[0].col是最大
						--f_CurSel;
				else if(f_CurSel==VACANCY[0].row) //HsMenu[0].row是最小
						f_CurSel = VACANCY[0].col;		
				Lcd_Clear(0);
				ShowMenu(VACANCY);		//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
				Init_KeyNumuber();			

		}
		 if(nChar ==KEYDOWN)//下翻	--
		{
					i=0;
			    j=0;
					//ResetTimer(TIMER_TIMEOUT);
					if (f_CurSel<VACANCY[0].col)
							++f_CurSel;
					else
							f_CurSel =  VACANCY[0].row;
					Lcd_Clear(0);
					ShowMenu(VACANCY);
					Init_KeyNumuber();	 

		}
		if(nChar ==KEYSURE) //确定
		{
					i=0;
			    j=0; 
					//KillTimer(TIMER_TIMEOUT);
					//g_WaitTimeOut = 0;
					Lcd_Clear(0);
			    //if (f_CurSel==4)
					//{break;}
			    temp_f_CurSel=f_CurSel;
					VACANCY[f_CurSel].pFunc(0);		//f_CurSel表示当前的行
			    f_CurSel=temp_f_CurSel;
			    ShowMenu(VACANCY);
					Init_KeyNumuber();			

		} 
		if( flag==0&&nChar ==KEYCLEAR)//取消
		{
			    i=0;
			    j++;
					//KeyNum =KEYNO;
			    delay_ms(100);
		   

		}
		if(j>=30)//按下超过3秒钟
		      {
		  	    j=0;
					  temp_f_CurSel=f_CurSel;
					  Choose_MenuOp4_3();
						//if(f_CurSel==2)	
						//break;
						f_CurSel=temp_f_CurSel;				
						ShowMenu(VACANCY);	
		      }
		else if (nChar !=KEYCLEAR&&j>0&&j<20)
		{
					i=0;
					j=0;
					Lcd_Clear(0);
					g_State = ST_IDLE;
					ResetKey();
					break;

		}
	}
  }
 // KillTimer(TIMER_TIMEOUT);
  g_State =ST_IDLE;
  return;
}
void Choose_MenuOp3_22(void)
{
  uchar flag=0,j=0,nChar,temp_f_CurSel;
	int i=0;
  //GUI_Clear(White);
 // ResetKey();			//Key_Num =KEYNO
  f_CurSel =NOVACANCY[0].row;
  //g_WaitTimeOut = 0;
  //SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
  // while( g_WaitTimeOut == 0 )  //超时等待
	//void InsertKey(uchar nChar){ Key_Num =nChar;}
  //InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
	delay_ms(100);
	Lcd_Clear(0);	    //清屏
	ShowMenu(NOVACANCY);
  while(1)
  {
		Init_KeyNumuber();	
		nChar = GetKey();   //读取按键缓冲区
		if(guanjiflag==1)
		{
			break;
    }
		else{
    		if(nChar ==KEYINIT)  //超时关屏即屏保
		{
			i++;
			//Delay(100);
			delay_ms(100);
		  if(i>=choosetime)//按下超过10秒钟
		  {
		  	LCD_LIGHT_OFF;
			  flag=1;
		  	i=0;
		  }
		}
		if(flag==1&&(nChar ==KEYCLEAR||nChar ==KEYSURE||nChar ==KEYDOWN||nChar == KEYUP))
		{
			LCD_LIGHT_ON;
			flag=0;
			delay_ms(1000);
			nChar =KEYINIT;
    }
	 if(nChar == KEYUP)	//上翻	++
		{
				i=0;
        j=0;			
				ResetTimer(TIMER_TIMEOUT);		//还没实现
				if (f_CurSel>NOVACANCY[0].row)		//HsMenu[0].col是最大
						--f_CurSel;
				else if(f_CurSel==NOVACANCY[0].row) //HsMenu[0].row是最小
						f_CurSel = NOVACANCY[0].col;		
				Lcd_Clear(0);
				ShowMenu(NOVACANCY);		//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
			  Init_KeyNumuber();	 

		} if(nChar ==KEYDOWN)//下翻	--
		{
					i=0;
          j=0;
					ResetTimer(TIMER_TIMEOUT);
					if (f_CurSel<NOVACANCY[0].col)
							++f_CurSel;
					else
							f_CurSel =  NOVACANCY[0].row;
					Lcd_Clear(0);
					ShowMenu(NOVACANCY);
					Init_KeyNumuber();	 

		}
		if(nChar ==KEYSURE) //确定
		{
					i=0;
          j=0; 
					//KillTimer(TIMER_TIMEOUT);
					//g_WaitTimeOut = 0;
					Lcd_Clear(0);
			    //if (f_CurSel==4)
					//{break;}
			    temp_f_CurSel=f_CurSel;
					NOVACANCY[f_CurSel].pFunc(0);		//f_CurSel表示当前的行
			    f_CurSel=temp_f_CurSel;
			    ShowMenu(NOVACANCY);
					Init_KeyNumuber();	  

		}
		if( flag==0&&nChar ==KEYCLEAR)//取消
		{
			    i=0;
			    j++;
					//KeyNum =KEYNO;
			    delay_ms(100);
		   

		}
		if(j>=30)//按下超过3秒钟
		      {
		  	    j=0;
					  temp_f_CurSel=f_CurSel;
					  Choose_MenuOp4_3();
						//if(f_CurSel==2)	
						//break;
						f_CurSel=temp_f_CurSel;				
						ShowMenu(NOVACANCY);	
		      }
		else if (nChar !=KEYCLEAR&&j>0&&j<20)
		{
			    i=0;
          j=0;
					Lcd_Clear(0);
					g_State = ST_IDLE;	
          ResetKey();			
					break;

		}
	}
  }
 // KillTimer(TIMER_TIMEOUT);
  g_State =ST_IDLE;
  return;
}
/*显示界面的入口*/
void Choose_MenuOp4(void)
{
  uchar flag=0,j=0,nChar,temp_f_CurSel;
	int i=0;
  //GUI_Clear(White);
  //ResetKey();			//Key_Num =KEYNO
  f_CurSel =TOOLMENU[0].row;
  //g_WaitTimeOut = 0;
  //SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
  // while( g_WaitTimeOut == 0 )  //超时等待
	//void InsertKey(uchar nChar){ Key_Num =nChar;}
  //InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
	delay_ms(100);
	Lcd_Clear(0);	 
	ShowMenu(TOOLMENU);
  while(1)
  {
		Init_KeyNumuber();
		nChar = GetKey();   //读取按键缓冲区
		if(guanjiflag==1)
			break;
		else{
			if(nChar ==KEYINIT)  //超时关屏
		{
			i++;
			//Delay(100);
			delay_ms(100);
		  if(i>=choosetime)//按下超过10秒钟
		  {
		  	LCD_LIGHT_OFF;
			  flag=1;
		  	i=0;
		  }
		}
		if(flag==1&&(nChar ==KEYCLEAR||nChar ==KEYSURE||nChar ==KEYDOWN||nChar == KEYUP))
		{
			LCD_LIGHT_ON;
			flag=0;
			delay_ms(1000);
			nChar =KEYINIT;
    }
		 if(nChar == KEYUP)	//上翻	++
		{
				i=0;
        j=0;
				//ResetTimer(TIMER_TIMEOUT);		//还没实现
				if (f_CurSel>TOOLMENU[0].row)		//HsMenu[0].col是最大
						--f_CurSel;
				else if(f_CurSel==TOOLMENU[0].row) //HsMenu[0].row是最小
						f_CurSel = TOOLMENU[0].col;		
				Lcd_Clear(0);
				ShowMenu(TOOLMENU);		//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
				//InsertKey(KEYNO); 
				Init_KeyNumuber();

		} if(nChar ==KEYDOWN)//下翻	--
		{
					i=0;
          j=0;
					//ResetTimer(TIMER_TIMEOUT);
					if (f_CurSel<TOOLMENU[0].col)
							++f_CurSel;
					else
							f_CurSel =  TOOLMENU[0].row;
					Lcd_Clear(0);
					ShowMenu(TOOLMENU);
					InsertKey(KEYNO); 

		}
		 if(nChar ==KEYSURE) //确定
		{
					 i=0;
           j=0;
					//KillTimer(TIMER_TIMEOUT);
					//g_WaitTimeOut = 0;
					Lcd_Clear(0);
			    temp_f_CurSel=f_CurSel;
			    TOOLMENU[f_CurSel].pFunc(0);
			    f_CurSel=temp_f_CurSel;
			    //ShowMenu(OPEN);//f_CurSel表示当前的行
					Init_KeyNumuber();
			    ShowMenu(TOOLMENU);	

		} 
		if( flag==0&&nChar ==KEYCLEAR)//取消
		{
			    i=0;
			    j++;
					//KeyNum =KEYNO;
			    delay_ms(100);
		   

		}
		if(j>=30)//按下超过3秒钟
		      {
		  	    j=0;
					  temp_f_CurSel=f_CurSel;
					  Choose_MenuOp4_3();
						//if(f_CurSel==2)	
						//break;
						f_CurSel=temp_f_CurSel;				
						ShowMenu(TOOLMENU);	
		      }
		else if (nChar !=KEYCLEAR&&j>0&&j<20)//取消
		{
			    i=0;
          j=0;
					Lcd_Clear(0);
					g_State = ST_IDLE;
					ResetKey();
					break;

		}
	}
  }
  //KillTimer(TIMER_TIMEOUT);
  g_State =ST_IDLE;
  return;
}

void Choose_MenuOp4_1(void)
{
  uchar i,k,flag=0,j=0,nChar,temp_f_CurSel;
	  //GUI_Clear(White);
  //ResetKey();			//Key_Num =KEYNO
  f_CurSel =CODEMENU[0].row;
  //g_WaitTimeOut = 0;
  //SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
  // while( g_WaitTimeOut == 0 )  //超时等待
	//void InsertKey(uchar nChar){ Key_Num =nChar;}
  //InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
	Lcd_Clear(0);	 
	ShowMenu(CODEMENU);
  g_WaitTimeOut = 0;
  SetTimer(TIMER_TIMEOUT,10,Do_TimeOut,THREE_MIN);
	while(g_WaitTimeOut == 0)
	{
			nChar =Read_RfidData(2,Rfid_Buff,0xff);
			if(nChar ==5)
			{
					display_shuzi(32,80,Rfid_Buff,Red,White);
					++rfidrow;
					delay_ms(1000);		
					for(i=0;i<4;i++)
					{
							for(k =0;k<40;k++)
								msDelay(500);
							WritEDAta(CAIMA_START+8*rfidrow+4+i,Rfid_Buff[i]);
					}				
					break;
			}

	}	
  KillTimer(TIMER_TIMEOUT);
					
	
  while(1)
  {
		Init_KeyNumuber();
		nChar = GetKey();   //读取按键缓冲区
		if(nChar ==KEYINIT)
		{
			Delay(100);
			//Lcd_Clear(0);	    //清屏
			//ShowMenu(TOOLMENU);		//显示菜单
			//InsertKey(KEYNO);		//Key_Num =nChar;
		}
		 if(nChar == KEYUP)	//上翻	++
		{
				
				//ResetTimer(TIMER_TIMEOUT);		//还没实现
				if (f_CurSel>CODEMENU[0].row)
						--f_CurSel;
				else if(f_CurSel==CODEMENU[0].row) 
						f_CurSel = CODEMENU[0].col;	
				Lcd_Clear(0);
				ShowMenu(CODEMENU);		//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
				display_shuzi(32,80,Rfid_Buff,Red,White);
				//InsertKey(KEYNO); 
				Init_KeyNumuber();

		} if(nChar ==KEYDOWN)//下翻	--
		{
					
					ResetTimer(TIMER_TIMEOUT);
					if (f_CurSel<TOOLMENU[0].col)
							++f_CurSel;
					else
							f_CurSel =  TOOLMENU[0].row;
					Lcd_Clear(0);
					ShowMenu(TOOLMENU);
					Init_KeyNumuber(); 

		}
		if(nChar ==KEYSURE) //确定
		{
					 
					//KillTimer(TIMER_TIMEOUT);
					//g_WaitTimeOut = 0;
					Lcd_Clear(0);
			    if(f_CurSel==3)
					{
						ShowMenu(CODEMENU);
						g_WaitTimeOut = 0;
            SetTimer(TIMER_TIMEOUT,10,Do_TimeOut,THREE_MIN);
						while(g_WaitTimeOut == 0)
						{
								nChar =Read_RfidData(2,Rfid_Buff,0xff);
								if(nChar ==5) 
								{
										display_shuzi(32,80,Rfid_Buff,Red,White);
										++rfidrow;
										delay_ms(1000);						
										for(i=0;i<4;i++)
										{
												for(k =0;k<40;k++)
													msDelay(500);
												WritEDAta(CAIMA_START+8*rfidrow+4+i,Rfid_Buff[i]);
										}										
										break;
								}
						}	

          KillTimer(TIMER_TIMEOUT);
          }
					else
				  {
						Lcd_Clear(0);
						g_State = ST_IDLE;
						ResetKey();
						break;
					}
					Init_KeyNumuber();

		}
		 if( nChar ==KEYCLEAR)//取消
		{
					Lcd_Clear(0);
					g_State = ST_IDLE;
					ResetKey();
					break;

		}
  }
  g_State =ST_IDLE;
  return;
}


void Choose_MenuOp4_2(void)
{
  uchar nChar, temp_f_CurSel;
  //GUI_Clear(White);
  //ResetKey();			//Key_Num =KEYNO
  f_CurSel =OPEN[0].row;
//   g_WaitTimeOut = 0;
//   SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
//   while( g_WaitTimeOut == 0 )  //超时等待

	delay_ms(100);
	Lcd_Clear(0);	    //清屏
	ShowMenu(OPEN);		//显示菜单
	//void InsertKey(uchar nChar){ Key_Num =nChar;}	
  //InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
	
	
	while(1)
	{
			often_show(16,56,"reading RFID",0,0x0fff);
			delay_ms(1000);	
			nChar =Read_RfidData(2,Rfid_Buff,0xff);
			//m_UB1;
			if(nChar ==5) 
			{
				if(Rfid_Buff[0]==0&&Rfid_Buff[1]==0&&Rfid_Buff[2]==0&&Rfid_Buff[3]==0)
					;
				else		//至少有一个不为零
				{
					//UARTnSendChar(1,Rfid_Buff,5);
					//apoint_place_write(56,80,Rfid_Buff,Red,White);
					display_shuzi(36,80, Rfid_Buff, Green, Yellow);
					delay_ms(1000);						
					break;
				}
			}
	}		
	
	
	
	result=check_suoma();
	if(result==1)
	{
		KEY_POWER_ON;
		often_show(36,100,"已授权",0,0x0fff);			
	}
	else
		often_show(36,100,"未授权",0,0x0fff);	
	
  while(1)
  {
		
		//apoint_place_write(32,0,lcd_buf2,0,0x0fff);
		Init_KeyNumuber();			
		nChar = GetKey();   //读取按键缓冲区
		if(nChar ==KEYINIT)
		{
			
				
			//apoint_place_write(96,0,lcd_buf_batt0,0,0x0fff);	
			/*if(Power_Cheak() ==0)
					{
				  apoint_place_write(96,0,lcd_buf_batt0,0,0x0fff);	
					}
			else if(Power_Cheak() ==1)
					{
				  apoint_place_write(96,0,lcd_buf_batt3,0,0x0fff);	
					}
			     else if(Power_Cheak() ==2)
					{
				  apoint_place_write(96,0,lcd_buf_batt1,0,0x0fff);	
					}
			          else if(Power_Cheak() ==3)
					{
				  apoint_place_write(96,0,lcd_buf_batt2,0,0x0fff);	
					}
			if(USB_Cheak_init()==1)  //USB_CHEAK ==(GPIO_Pin_12)
			{
				apoint_place_write(96,0,lcd_buf_signal,0,0x0fff);
      }
			else
			{
				apoint_place_write(96,0,lcd_buf_nosignal,0,0x0fff);
      }*/
			//InsertKey(KEYNO);		//Key_Num =nChar;
			Delay(100);
		}
		else if(nChar == KEYUP)	//上翻	++
		{
				 
				//ResetTimer(TIMER_TIMEOUT);		//还没实现
				if (f_CurSel>OPEN[0].row)		//HsMenu[0].col是最大
						--f_CurSel;
				else if(f_CurSel==OPEN[0].row) //HsMenu[0].row是最小
						f_CurSel = OPEN[0].col;		//HsMenu[0].row是最小
				Lcd_Clear(0);
				ShowMenu(OPEN);		//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
				//apoint_place_write(32,0,lcd_buf2,0,0x0fff);	
				//apoint_place_write(96,0,lcd_buf_batt0,0,0x0fff);	
				/*if(Power_Cheak() ==0)
					{
				  apoint_place_write(96,0,lcd_buf_batt0,0,0x0fff);	
						}
					if(Power_Cheak() ==1)
					{
				  apoint_place_write(96,0,lcd_buf_batt3,0,0x0fff);	
						}
					if(Power_Cheak() ==2)
					{
				  apoint_place_write(96,0,lcd_buf_batt1,0,0x0fff);	
						}
						if(Power_Cheak() ==3)
					{
				  apoint_place_write(96,0,lcd_buf_batt2,0,0x0fff);	
						}
						if(USB_Cheak_init()==1)
			     {
				     apoint_place_write(96,0,lcd_buf_signal,0,0x0fff);
           }
			      else
			     {
				     apoint_place_write(96,0,lcd_buf_nosignal,0,0x0fff);
           }*/
				Init_KeyNumuber();

		}
 	 if(nChar ==KEYDOWN)//下翻	--
 		{
 					
 					//ResetTimer(TIMER_TIMEOUT);
 					if (f_CurSel<OPEN[0].col)
 							++f_CurSel;
 					else
 							f_CurSel =  OPEN[0].row;
 					Lcd_Clear(0);
 					ShowMenu(OPEN);
// 					apoint_place_write(32,0,lcd_buf2,0,0x0fff);	
// 					/*if(Power_Cheak() ==0)
// 					{
// 				  apoint_place_write(96,0,lcd_buf_batt0,0,0x0fff);	
// 						}
// 					if(Power_Cheak() ==1)
// 					{
// 				  apoint_place_write(96,0,lcd_buf_batt3,0,0x0fff);	
// 						}
// 					if(Power_Cheak() ==2)
// 					{
// 				  apoint_place_write(96,0,lcd_buf_batt1,0,0x0fff);	
// 						}
// 						if(Power_Cheak() ==3)
// 					{
// 				  apoint_place_write(96,0,lcd_buf_batt2,0,0x0fff);	
// 						}
// 			if(USB_Cheak_init()==1)
// 			{
// 				apoint_place_write(96,0,lcd_buf_signal,0,0x0fff);
//       }
// 			else
// 			{
// 				apoint_place_write(96,0,lcd_buf_nosignal,0,0x0fff);
//       }*/
 					Init_KeyNumuber();
// 					delay_ms(1);
//           GPIOC->IDR= GPIO_Pin_8;

 		}
		else if(nChar ==KEYSURE) //确定
		{
					 
					//KillTimer(TIMER_TIMEOUT);
					//g_WaitTimeOut = 0;
					Lcd_Clear(0);
			    temp_f_CurSel=f_CurSel;
					OPEN[f_CurSel].pFunc(0);		//f_CurSel表示当前的行
			    f_CurSel=temp_f_CurSel;
					Init_KeyNumuber();

		}else if( nChar ==KEYCLEAR)//取消
		{
					//KeyNum =KEYNO;
					Lcd_Clear(0);
					g_State = ST_IDLE;
					ResetKey();
					break;

		}
  }
  //KillTimer(TIMER_TIMEOUT);
  g_State =ST_IDLE;
  return;
}

void Choose_MenuOp4_22(void)
{
  uchar flag=0,j=0,nChar, temp_f_CurSel=0;
	int i=0;
  //GUI_Clear(White);
  //ResetKey();			//Key_Num =KEYNO
  f_CurSel =MIMA[0].row;
//   g_WaitTimeOut = 0;
//   SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
//   while( g_WaitTimeOut == 0 )  //超时等待

	delay_ms(100);
	Lcd_Clear(0);	    //清屏
	ShowMenu(MIMA);		//显示菜单
	//void InsertKey(uchar nChar){ Key_Num =nChar;}	
  //InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键	
	
  while(1)
  {
		
		Init_KeyNumuber();			
		nChar = GetKey();   //读取按键缓冲区
		if(guanjiflag==1)
			break;
		else{
			if(nChar ==KEYINIT)  //超时关屏
		{
			i++;
			//Delay(100);
			delay_ms(100);
		  if(i>=choosetime)//按下超过10秒钟
		  {
		  	LCD_LIGHT_OFF;
			  flag=1;
		  	i=0;
		  }
		}
		if(flag==1&&(nChar ==KEYCLEAR||nChar ==KEYSURE||nChar ==KEYDOWN||nChar == KEYUP))
		{
			LCD_LIGHT_ON;
			flag=0;
			delay_ms(1000);
			nChar =KEYINIT;
    }
		 if(nChar == KEYUP)	//上翻	++
		{
				i=0;
        j=0;
				//ResetTimer(TIMER_TIMEOUT);		//还没实现
				//if (f_CurSel<MIMA[0].col)		//HsMenu[0].col是最大
					//	++f_CurSel;
				//else if(f_CurSel==MIMA[0].col) //HsMenu[0].row是最小
					//	f_CurSel = MIMA[0].row;		//HsMenu[0].row是最小
				//Lcd_Clear(0);
				//ShowMenu(MIMA);		//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
			    ++MIMA[f_CurSel].Name[0];
			    if(MIMA[f_CurSel].Name[0]>57)
						MIMA[f_CurSel].Name[0]='0';
					code[f_CurSel-5]=MIMA[f_CurSel].Name[0];
				  Init_KeyNumuber();
			    ShowMenu(MIMA);	
          delay_ms(100);
		}
 	  if(nChar ==KEYDOWN)//下翻	--
 		{
 					i=0;
          j=0;
 					--MIMA[f_CurSel].Name[0];
			    if(MIMA[f_CurSel].Name[0]<48)
						MIMA[f_CurSel].Name[0]='9';
					code[f_CurSel-5]=MIMA[f_CurSel].Name[0];
          Init_KeyNumuber();
					ShowMenu(MIMA);	
          delay_ms(100);
 		}
		 if(nChar ==KEYSURE) //确定
		{
					 i=0;
           j=0;
					//KillTimer(TIMER_TIMEOUT);
					//g_WaitTimeOut = 0;
					//Lcd_Clear(0);
			    //temp_f_CurSel=f_CurSel;
					//MIMA[f_CurSel].pFunc(0);		//f_CurSel表示当前的行
			    //f_CurSel=temp_f_CurSel;
			    //MIMA[6].Name[temp_f_CurSel]='3';
			    //++temp_f_CurSel;
					//Init_KeyNumuber();
			    //ShowMenu(MIMA);	
			  if (f_CurSel<MIMA[0].col)
				{					//HsMenu[0].col是最大
						++f_CurSel;
					  Init_KeyNumuber();
					  ShowMenu(MIMA);	
					  delay_ms(1000);
				}
				else if(f_CurSel==MIMA[0].col) //HsMenu[0].row是最小
				{   
					  if(strcmp(code,rightcode))
				    {
					Lcd_Clear(0);
					often_show(36,64,"密码错误！",0,0x0fff);
				  often_show(30,32,"请重新输入",0,0x0fff);
					strcpy((char*)code,"    ");
					MIMA[5].Name[0]='0';
					MIMA[6].Name[0]='0';
					MIMA[7].Name[0]='0';
					MIMA[8].Name[0]='0';
				  delay_ms(3000);
					Lcd_Clear(0);
				  f_CurSel = MIMA[0].row;		//HsMenu[0].row是最小
				  ShowMenu(MIMA);
					Init_KeyNumuber();
				    }
				    else if(strcmp(code,rightcode)==0)
				    {
					Lcd_Clear(0);
					often_show(32,48,"密码正确！",0,0x0fff);
					often_show(40,80,"开锁中",0,0x0fff);
					Delay(100);
					KEY_POWER_ON;		
	        delay_ms(5000);		
          KEY_POWER_OFF;
					Lcd_Clear(0);
					strcpy((char*)code,"    ");
					MIMA[5].Name[0]='0';
					MIMA[6].Name[0]='0';
					MIMA[7].Name[0]='0';
					MIMA[8].Name[0]='0';
					break;
				    }
					}
				}
		 if( flag==0&&nChar ==KEYCLEAR)//取消
		{
			    i=0;
			    j++;
					//KeyNum =KEYNO;
			    delay_ms(100);
		   
		}
		if(j>=30)//按下超过3秒钟
		      {
		  	    j=0;
					  temp_f_CurSel=f_CurSel;
					  Choose_MenuOp4_3();
						//if(f_CurSel==2)	
						//break;
						f_CurSel=temp_f_CurSel;				
						ShowMenu(MIMA);	
		      }
		else if (nChar !=KEYCLEAR&&j>0&&j<20)//取消
		{
					i=0;
          j=0;//KeyNum =KEYNO;
					Lcd_Clear(0);
					g_State = ST_IDLE;
					ResetKey();
					break;
		}
  }
}
  //KillTimer(TIMER_TIMEOUT);
  g_State =ST_IDLE;
  return;
}
void Choose_MenuOp4_3(void)
{
  uchar flag=0,j=0,nChar,temp_f_CurSel;
	int i=0;
  //GUI_Clear(White);
  //ResetKey();			//Key_Num =KEYNO
  f_CurSel =GUANJI[0].row;
  //g_WaitTimeOut = 0;
  //SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
  // while( g_WaitTimeOut == 0 )  //超时等待
	//void InsertKey(uchar nChar){ Key_Num =nChar;}
  //InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
	delay_ms(100);
	Lcd_Clear(0);	 
	ShowMenu(GUANJI);
  while(1)
  {
		Init_KeyNumuber();
		nChar = GetKey();   //读取按键缓冲区
		if(guanjiflag==1)
			break;
		else{
			if(nChar ==KEYINIT)  //超时关屏
		{
			i++;
			//Delay(100);
			delay_ms(100);
		  if(i>=choosetime)//按下超过10秒钟
		  {
		  	LCD_LIGHT_OFF;
			  flag=1;
		  	i=0;
		  }
		}
		if(flag==1&&(nChar ==KEYCLEAR||nChar ==KEYSURE||nChar ==KEYDOWN||nChar == KEYUP))
		{
			LCD_LIGHT_ON;
			flag=0;
			delay_ms(1000);
			nChar =KEYINIT;
    }
		 if(nChar == KEYUP)	//上翻	++
		{
				i=0;
			  j=0;
				//ResetTimer(TIMER_TIMEOUT);		//还没实现
				if (f_CurSel>GUANJI[0].row)
						--f_CurSel;
				else if(f_CurSel==GUANJI[0].row) 
						f_CurSel = GUANJI[0].col;	
				Lcd_Clear(0);
				ShowMenu(GUANJI);		//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
				//InsertKey(KEYNO); 
				Init_KeyNumuber();

		} if(nChar ==KEYDOWN)//下翻	--
		{
					i=0;
			    j=0;
					//ResetTimer(TIMER_TIMEOUT);
					if (f_CurSel<GUANJI[0].col)
							++f_CurSel;
					else
							f_CurSel =  GUANJI[0].row;
					Lcd_Clear(0);
					ShowMenu(GUANJI);
					Init_KeyNumuber(); 

		}
		 if(nChar ==KEYSURE) //确定
		{
					i=0;
			    j=0; 
					//KillTimer(TIMER_TIMEOUT);
					//g_WaitTimeOut = 0;
					Lcd_Clear(0);
			if(f_CurSel==3)
				break;
			else
			    GUANJI[f_CurSel].pFunc(0);
			if(guanjiflag==1)
			break;
			    //ShowMenu(OPEN);
							//f_CurSel表示当前的行
					Init_KeyNumuber();
			//if(guanjiflag==0)
			    //ShowMenu(GUANJI);	
			//else 
				  //ShowMenu(KAIJI);

		}//else if( nChar ==KEYCLEAR)//取消
		//{
			//		Lcd_Clear(0);
			//		g_State = ST_IDLE;
			//		ResetKey();
			//		break;

	//	}
	}
  }
  //KillTimer(TIMER_TIMEOUT);
  g_State =ST_IDLE;
  return;
}
/*显示界面的入口*/
void Choose_MenuOp4_4(void)
{
  uchar flag=0,j=0,epi,epr,hangj,jj,k=0,nChar,temp_f_CurSel=0,tempdata[2],tempsuoma[4],recordsuoma[4];
	uchar row,recordrow;
	int i=0;
  //GUI_Clear(White);
  //ResetKey();			//Key_Num =KEYNO
  f_CurSel =JIANCHA[0].row;
//   g_WaitTimeOut = 0;
//   SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
//   while( g_WaitTimeOut == 0 )  //超时等待

	delay_ms(100);
	Lcd_Clear(0);	    //清屏
	ShowMenu(JIANCHA);		//显示菜单
	//void InsertKey(uchar nChar){ Key_Num =nChar;}	
  //InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
	row=ReadData(AUTHOR_ROW_L);
	recordrow=ReadData(RECORD_ROW_L);
	for(epi=0,hangj=0;epi<row;epi++,hangj++)
	{
	tempdata[0]=ReadData(AUTHOR_START+2+epi*24);
	tempdata[1]=ReadData(AUTHOR_START+3+epi*24);
	tempsuoma[0]=ReadData(AUTHOR_START+4+epi*24);
  tempsuoma[1]=ReadData(AUTHOR_START+5+epi*24);
	tempsuoma[2]=ReadData(AUTHOR_START+6+epi*24);
	tempsuoma[3]=ReadData(AUTHOR_START+7+epi*24);
		for(epr=0;epr<recordrow;epr++)
		{
			recordsuoma[0]=ReadData(RECORD_START+0+epr*5);
			recordsuoma[1]=ReadData(RECORD_START+1+epr*5);
			recordsuoma[2]=ReadData(RECORD_START+2+epr*5);
			recordsuoma[3]=ReadData(RECORD_START+3+epr*5);
			if(tempsuoma[0]==recordsuoma[0]&&tempsuoma[1]==recordsuoma[1]&&tempsuoma[2]==recordsuoma[2]&&tempsuoma[3]==recordsuoma[3])
			{
				if(ReadData(RECORD_START+4+epr*5)==1)
					often_show(80,32+hangj*16,"已检查",0,0x0fff);
				else
					often_show(80,32+hangj*16,"未检查",0,0x0fff);
      }
			else
				  often_show(80,32+hangj*16,"未检查",0,0x0fff);
		}
	display_shuzi_zijie(16,32+hangj*16, tempdata, Green, Yellow);
	//hangj=hangj-48;
	if(epi>=6)
	{
		//temp_f_CurSel=1;
		k++;                                               //页数
		break;
		
	}
	}
  while(1)
  {
		
		//apoint_place_write(32,0,lcd_buf2,0,0x0fff);
		Init_KeyNumuber();			
		nChar = GetKey();   //读取按键缓冲区
		if(guanjiflag==1)
			break;
		else{
			if(nChar ==KEYINIT)  //超时关屏
		{
			i++;
			//Delay(100);
			delay_ms(100);
		  if(i>=choosetime)//按下超过10秒钟
		  {
		  	LCD_LIGHT_OFF;
			  flag=1;
		  	i=0;
		  }
		}
		if(flag==1&&(nChar ==KEYCLEAR||nChar ==KEYSURE||nChar ==KEYDOWN||nChar == KEYUP))
		{
			LCD_LIGHT_ON;
			flag=0;
			delay_ms(1000);
			nChar =KEYINIT;
    }
	  if(nChar == KEYUP)	//上翻	++
		{
			  i=0;
			  j=0;
				if (k!=0)
				{
					Lcd_Clear(0);
				  ShowMenu(JIANCHA);
          for(j=0,epi=0+7*k,hangj=0;epi<row;epi++,hangj++)
	        {
	           tempdata[0]=ReadData(AUTHOR_START+2+(epi+k)*24);
	           tempdata[1]=ReadData(AUTHOR_START+3+(epi+k)*24);
						 tempsuoma[0]=ReadData(AUTHOR_START+4+(epi+k)*24);
             tempsuoma[1]=ReadData(AUTHOR_START+5+(epi+k)*24);
	           tempsuoma[2]=ReadData(AUTHOR_START+6+(epi+k)*24);
	           tempsuoma[3]=ReadData(AUTHOR_START+7+(epi+k)*24);
							for(epr=0;epr<recordrow;epr++)
									{
										recordsuoma[0]=ReadData(RECORD_START+0+epr*5);
										recordsuoma[1]=ReadData(RECORD_START+1+epr*5);
										recordsuoma[2]=ReadData(RECORD_START+2+epr*5);
										recordsuoma[3]=ReadData(RECORD_START+3+epr*5);
										if(tempsuoma[0]==recordsuoma[0]&&tempsuoma[1]==recordsuoma[1]&&tempsuoma[2]==recordsuoma[2]&&tempsuoma[3]==recordsuoma[3])
										{
											if(ReadData(RECORD_START+4+epr*5)==1)
												often_show(80,32+hangj*16,"已检查",0,0x0fff);
											else
												often_show(80,32+hangj*16,"未检查",0,0x0fff);
										}
										else
				                often_show(80,32+hangj*16,"未检查",0,0x0fff);
									}
	           display_shuzi_zijie(16,32+hangj*16, tempdata, Green, Yellow);
	           hangj=hangj-48;
	           if(epi>=6+7*k)
							{
								 k++;
								 jj=1;
								 //temp_f_CurSel=1;
								 Init_KeyNumuber();
								 break;
							}
		       }			 
							 if(epi<6+7*(k-jj))
									{
										//temp_f_CurSel=0;
										k=0;
										nChar = KEYINIT;
										delay_ms(1000);
									}	 
						}
		 if(k==0 && nChar == KEYUP)
		 {
					Lcd_Clear(0);
				  ShowMenu(JIANCHA);
					for(epi=0,hangj=0;epi<row;epi++,hangj++)
						{
						tempdata[0]=ReadData(AUTHOR_START+2+epi*24);
						tempdata[1]=ReadData(AUTHOR_START+3+epi*24);
						tempsuoma[0]=ReadData(AUTHOR_START+4+epi*24);
            tempsuoma[1]=ReadData(AUTHOR_START+5+epi*24);
	          tempsuoma[2]=ReadData(AUTHOR_START+6+epi*24);
	          tempsuoma[3]=ReadData(AUTHOR_START+7+epi*24);
						for(epr=0;epr<recordrow;epr++)
									{
										recordsuoma[0]=ReadData(RECORD_START+0+epr*5);
										recordsuoma[1]=ReadData(RECORD_START+1+epr*5);
										recordsuoma[2]=ReadData(RECORD_START+2+epr*5);
										recordsuoma[3]=ReadData(RECORD_START+3+epr*5);
										if(!strcmp(tempsuoma,recordsuoma))
										{
											if(ReadData(RECORD_START+4+epr*5)==1)
												often_show(80,32+hangj*16,"已检查",0,0x0fff);
											else
												often_show(80,32+hangj*16,"未检查",0,0x0fff);
										}
										else
				                often_show(80,32+hangj*16,"未检查",0,0x0fff);
									}
						display_shuzi_zijie(16,32+hangj*16, tempdata, Green, Yellow);
							if(epi>=6)
							{
								//temp_f_CurSel=1;
								k++;      								//页数
								break;
							}
						}
						Init_KeyNumuber();
			}
		}
// 	 if(nChar ==KEYDOWN)//下翻	--
// 		{
// 					i=0;
//		      j=0;
// 					//ResetTimer(TIMER_TIMEOUT);
// 					if (f_CurSel<HsMenu[0].col)
// 							++f_CurSel;
// 					else
// 							f_CurSel =  HsMenu[0].row;
// 					Lcd_Clear(0);
// 					ShowMenu(HsMenu);
// 					apoint_place_write(32,0,lcd_buf2,0,0x0fff);	
// 					/*if(Power_Cheak() ==0)
// 					{
// 				  apoint_place_write(96,0,lcd_buf_batt0,0,0x0fff);	
// 						}
// 					if(Power_Cheak() ==1)
// 					{
// 				  apoint_place_write(96,0,lcd_buf_batt3,0,0x0fff);	
// 						}
// 					if(Power_Cheak() ==2)
// 					{
// 				  apoint_place_write(96,0,lcd_buf_batt1,0,0x0fff);	
// 						}
// 						if(Power_Cheak() ==3)
// 					{
// 				  apoint_place_write(96,0,lcd_buf_batt2,0,0x0fff);	
// 						}
// 			if(USB_Cheak_init()==1)
// 			{
// 				apoint_place_write(96,0,lcd_buf_signal,0,0x0fff);
//       }
// 			else
// 			{
// 				apoint_place_write(96,0,lcd_buf_nosignal,0,0x0fff);
//       }*/
// 					Init_KeyNumuber();
// 					delay_ms(1);
//           GPIOC->IDR= GPIO_Pin_8;

// 		}
		 if(nChar ==KEYSURE) //确定
		{
					i=0;
			    j=0; 
					//KillTimer(TIMER_TIMEOUT);
					Lcd_Clear(0);
					g_State = ST_IDLE;
					ResetKey();
					break;

		}
if( flag==0&&nChar ==KEYCLEAR)//取消
		{
			    i=0;
			    j++;
					//KeyNum =KEYNO;
			    delay_ms(100);
		   

		}
		if(j>=30)//按下超过3秒钟
		      {
		  	    j=0;
					  temp_f_CurSel=f_CurSel;
					  Choose_MenuOp4_3();
						//if(f_CurSel==2)	
						//break;
						f_CurSel=temp_f_CurSel;				
						ShowMenu(TOOLMENU);	
		      }
		else if (nChar !=KEYCLEAR&&j>0&&j<20)//取消
		{
			    i=0;
			    j=0;
					//KeyNum =KEYNO;
					Lcd_Clear(0);
					g_State = ST_IDLE;
					ResetKey();
					break;

		}
  }
}
  //KillTimer(TIMER_TIMEOUT);
  g_State =ST_IDLE;
  return;
}
/*显示界面的入口*/
void Choose_MenuOp5(void)
{
  uchar flag=0,j=0,nChar,temp_f_CurSel;
	int i=0;
  //GUI_Clear(White);
  //ResetKey();			//Key_Num =KEYNO
  f_CurSel =SETMENU[0].row;
//   g_WaitTimeOut = 0;
//   SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
//   while( g_WaitTimeOut == 0 )  //超时等待

	delay_ms(100);
	Lcd_Clear(0);	    //清屏
	ShowMenu(SETMENU);		//显示菜单
	//void InsertKey(uchar nChar){ Key_Num =nChar;}	
  //InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
	
  while(1)
  {
		
		//apoint_place_write(32,0,lcd_buf2,0,0x0fff);
		Init_KeyNumuber();			
		nChar = GetKey();   //读取按键缓冲区
		if(guanjiflag==1)
			break;
		else{
			if(nChar ==KEYINIT)  //超时关屏
		{
			i++;
			//Delay(100);
			delay_ms(100);
		  if(i>=choosetime)//按下超过10秒钟
		  {
		  	LCD_LIGHT_OFF;
			  flag=1;
		  	i=0;
		  }
		}
		if(flag==1&&(nChar ==KEYCLEAR||nChar ==KEYSURE||nChar ==KEYDOWN||nChar == KEYUP))
		{
			LCD_LIGHT_ON;
			flag=0;
			delay_ms(1000);
			nChar =KEYINIT;
    }
	 if(nChar == KEYUP)	//上翻	++
		{
				i=0;
        j=0;			
				//ResetTimer(TIMER_TIMEOUT);		//还没实现
				if (f_CurSel>SETMENU[0].row)		//HsMenu[0].col是最大
						--f_CurSel;
				else if(f_CurSel==SETMENU[0].row) //HsMenu[0].row是最小
						f_CurSel = SETMENU[0].col;		//HsMenu[0].row是最小
				Lcd_Clear(0);
				ShowMenu(SETMENU);		//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
				Init_KeyNumuber();

		}
 		 if(nChar ==KEYDOWN)//下翻	--
 		{
 					i=0;
          j=0;	
 					//ResetTimer(TIMER_TIMEOUT);
 					if (f_CurSel<SETMENU[0].col)
 							++f_CurSel;
 					else
 							f_CurSel =  SETMENU[0].row;
 					Lcd_Clear(0);
 					ShowMenu(SETMENU);
					Init_KeyNumuber();
 		}
		 if(nChar ==KEYSURE) //确定
		{
					i=0;
          j=0;	 
					//KillTimer(TIMER_TIMEOUT);
					//g_WaitTimeOut = 0;
					Lcd_Clear(0);
			    temp_f_CurSel=f_CurSel;
					SETMENU[f_CurSel].pFunc(0);				//f_CurSel表示当前的行
			    f_CurSel=temp_f_CurSel;
					ShowMenu(SETMENU);
					Init_KeyNumuber();

		}
		if( flag==0&&nChar ==KEYCLEAR)//取消
		{
			    i=0;
			    j++;
					//KeyNum =KEYNO;
			    delay_ms(100);
		   

		}
		if(j>=30)//按下超过3秒钟
		      {
		  	    j=0;
					  temp_f_CurSel=f_CurSel;
					  Choose_MenuOp4_3();
						//if(f_CurSel==2)	
						//break;
						f_CurSel=temp_f_CurSel;				
						ShowMenu(SETMENU);	
		      }
		else if (nChar !=KEYCLEAR&&j>0&&j<20)//取消
		{
			    i=0;
			    j=0;
					//KeyNum =KEYNO;
					Lcd_Clear(0);
					g_State = ST_IDLE;
					ResetKey();
					break;

		}
  }
}
  //KillTimer(TIMER_TIMEOUT);
  g_State =ST_IDLE;
  return;
}
void Choose_MenuOp5_1(void)
{
  uchar flag=0,j=0,nChar,temp_f_CurSel;
	int i=0;
  //GUI_Clear(White);
  //ResetKey();			//Key_Num =KEYNO
  f_CurSel=TIME[0].row;
//   g_WaitTimeOut = 0;
//   SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
//   while( g_WaitTimeOut == 0 )  //超时等待

	delay_ms(100);
	Lcd_Clear(0);	    //清屏
	ShowMenu(TIME);		//显示菜单
	//void InsertKey(uchar nChar){ Key_Num =nChar;}	
  //InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
	
  while(1)
  {
		
		//apoint_place_write(32,0,lcd_buf2,0,0x0fff);
		Init_KeyNumuber();			
		nChar = GetKey();   //读取按键缓冲区
		if(guanjiflag==1)
			break;
		else{
			if(nChar ==KEYINIT)  //超时关屏
		{
			i++;
			//Delay(100);
			delay_ms(100);
		  if(i>=choosetime)//按下超过10秒钟
		  {
		  	LCD_LIGHT_OFF;
			  flag=1;
		  	i=0;
		  }
		}
		if(flag==1&&(nChar ==KEYCLEAR||nChar ==KEYSURE||nChar ==KEYDOWN||nChar == KEYUP))
		{
			LCD_LIGHT_ON;
			flag=0;
			delay_ms(1000);
			nChar =KEYINIT;
    }
	  if(nChar == KEYUP)	//上翻	++
		{
				i=0;
        j=0;			
				//ResetTimer(TIMER_TIMEOUT);		//还没实现
				if (f_CurSel>TIME[0].row)		//HsMenu[0].col是最大
						--f_CurSel;
				else if(f_CurSel==TIME[0].row) //HsMenu[0].row是最小
						f_CurSel = TIME[0].col;		//HsMenu[0].row是最小
				Lcd_Clear(0);
				ShowMenu(TIME);		//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
				Init_KeyNumuber();

		}
 	 if(nChar ==KEYDOWN)//下翻	--
 		{
 					i=0;
          j=0;
 					//ResetTimer(TIMER_TIMEOUT);
 					if (f_CurSel<TIME[0].col)
 							++f_CurSel;
 					else
 							f_CurSel =  TIME[0].row;
 					Lcd_Clear(0);
 					ShowMenu(TIME);
 					Init_KeyNumuber();
 		}
	  if(nChar ==KEYSURE) //确定
		{
					i=0;
          j=0; 
					//KillTimer(TIMER_TIMEOUT);
					//g_WaitTimeOut = 0;
					Lcd_Clear(0);
			    if(f_CurSel==3)
			    choosetime=1000;
					else if(f_CurSel==4)
					     choosetime=300;
					     else if(f_CurSel==5)
						        choosetime=500;
          g_State = ST_IDLE;
					ResetKey();
					break;

		}
		if( flag==0&&nChar ==KEYCLEAR)//取消
		{
			    i=0;
			    j++;
					//KeyNum =KEYNO;
			    delay_ms(100);
		   

		}
		if(j>=30)//按下超过3秒钟
		      {
		  	    j=0;
					  temp_f_CurSel=f_CurSel;
					  Choose_MenuOp4_3();
						//if(f_CurSel==2)	
						//break;
						f_CurSel=temp_f_CurSel;				
						ShowMenu(TIME);	
		      }
		else if (nChar !=KEYCLEAR&&j>0&&j<20)//取消
		{
			    i=0;
          j=0;
					//KeyNum =KEYNO;
					Lcd_Clear(0);
					g_State = ST_IDLE;
					ResetKey();
					break;

		}
  }
}
  //KillTimer(TIMER_TIMEOUT);
  g_State =ST_IDLE;
  return;
}
void Choose_MenuOp5_3(void)
{
  uchar flag=0,j=0,nChar,temp_f_CurSel;
	int i=0;
  //GUI_Clear(White);
  //ResetKey();			//Key_Num =KEYNO
  f_CurSel =BANBEN[0].row;
//   g_WaitTimeOut = 0;
//   SetTimer(TIMER_TIMEOUT,3,Do_TimeOut,THREE_MIN);
//   while( g_WaitTimeOut == 0 )  //超时等待

	delay_ms(100);
	Lcd_Clear(0);	    //清屏
	ShowMenu(BANBEN);		//显示菜单
	//void InsertKey(uchar nChar){ Key_Num =nChar;}	
  //InsertKey(KEYINIT);   //在按键缓冲区，插入一个虚拟的初始化按键
	
  while(1)
  {
		
		//apoint_place_write(32,0,lcd_buf2,0,0x0fff);
		Init_KeyNumuber();			
		nChar = GetKey();   //读取按键缓冲区
		if(guanjiflag==1)
			break;
		else{
			if(nChar ==KEYINIT)  //超时关屏
		{
			i++;
			//Delay(100);
			delay_ms(100);
		  if(i>=choosetime)//按下超过10秒钟
		  {
		  	LCD_LIGHT_OFF;
			  flag=1;
		  	i=0;
		  }
		}
		if(flag==1&&(nChar ==KEYCLEAR||nChar ==KEYSURE||nChar ==KEYDOWN||nChar == KEYUP))
		{
			LCD_LIGHT_ON;
			flag=0;
			delay_ms(1000);
			nChar =KEYINIT;
    }
		if(nChar == KEYUP)	//上翻	++
		{
				i=0;
        j=0;			
				//ResetTimer(TIMER_TIMEOUT);		//还没实现
				if (f_CurSel>BANBEN[0].row)		//HsMenu[0].col是最大
						--f_CurSel;
				else if(f_CurSel==BANBEN[0].row) //HsMenu[0].row是最小
						f_CurSel = BANBEN[0].col;		//HsMenu[0].row是最小
				Lcd_Clear(0);
				ShowMenu(BANBEN);		//此时f_CurSel已经改变，清屏之后再显示时反白的行会改变
				Init_KeyNumuber();

		}
 		 if(nChar ==KEYDOWN)//下翻	--
 		{
 					i=0;
          j=0;
 					//ResetTimer(TIMER_TIMEOUT);
 					if (f_CurSel<BANBEN[0].col)
 							++f_CurSel;
					else
 							f_CurSel =  BANBEN[0].row;
 					Lcd_Clear(0);
 					ShowMenu(BANBEN);
					Init_KeyNumuber();
 		}
		 if(nChar ==KEYSURE) //确定
		{
					i=0;
          j=0; 
					//KillTimer(TIMER_TIMEOUT);
					//g_WaitTimeOut = 0;
					Lcd_Clear(0);
          g_State = ST_IDLE;
					ResetKey();
					break;

		}
		if( flag==0&&nChar ==KEYCLEAR)//取消
		{
			    i=0;
			    j++;
					//KeyNum =KEYNO;
			    delay_ms(100);
		   

		}
		if(j>=30)//按下超过3秒钟
		      {
		  	    j=0;
					  temp_f_CurSel=f_CurSel;
					  Choose_MenuOp4_3();
						//if(f_CurSel==2)	
						//break;
						f_CurSel=temp_f_CurSel;				
						ShowMenu(BANBEN);	
		      }
		else if (nChar !=KEYCLEAR&&j>0&&j<20)//取消 
		{
					//KeyNum =KEYNO;
			    i=0;
			    j=0;
					Lcd_Clear(0);
					g_State = ST_IDLE;
					ResetKey();
					break;

		}
  }
}
  //KillTimer(TIMER_TIMEOUT);
  g_State =ST_IDLE;
  return;
}
void Lcd_Clear(uchar para)		//其参数para没用
{
	GUI_Clear(White);		//直接调用ＧＵＩ＿Ｃｌｅａｒ函数，其将屏幕上的每一点都写为白

}

/**
当检测到电池电压过低的时候，LCD显示
电池电压过低，请及时充电
每过5分钟提示一次电池电压过低，如果检测到电池电压过低，则直接关机，
每次打开手持机的时候，先检测一下电池的电压，如果电池电压不足，则不打开

**/

void Lcd_Show_LowBattry(void)
{
 GUI_Clear(White);
 often_show(0,0,"电压过低!",0x00f,0xfff);
 often_show(0,17,"将自动关机",0x00f,0xfff);


}


/***
  当读取到ID编号的时候 将ID号显示于LCD上
为正确的编号则打开锁
为错误的编号 则显示 不在管理范围内
假定ID的16进制数都是小于0X0A的情况

***/

void Lcd_Show_IDinfo(void)
{
   uchar temp;
   uchar Lcd_LockBuff[9];
   GUI_Clear(White);
   temp=Lock_number[0];
   Lcd_LockBuff[0] =((temp&0xf0)>>4)+0x30;
   Lcd_LockBuff[1] =(temp&0x0f)+0x30;
   temp=Lock_number[1];
   Lcd_LockBuff[2]=((temp&0xf0)>>4)+0x30;
   Lcd_LockBuff[3]=(temp&0x0f)+0x30;
   temp=Lock_number[2];
   Lcd_LockBuff[4]=((temp&0xf0)>>4)+0x30;
   Lcd_LockBuff[5]=(temp&0x0f)+0x30;
   temp=Lock_number[3];
   Lcd_LockBuff[6]=((temp&0xf0)>>4)+0x30;
   Lcd_LockBuff[7]=(temp&0x0f)+0x30;
   Lcd_LockBuff[8] =0;
   often_show(0,0,"被打开锁的ID:",0,0x0fff);
   apoint_place_write(1,17,Lcd_LockBuff,0,0xfff);

}
/*
data,clk ,rs,rst,cs
*/
void  Lcd_PortInit(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;
 	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9;	    //CONTROL
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	   //cs,rs,wr,rd
	GPIO_Init(GPIOB, &GPIO_InitStructure);//控制引脚是GPIOB的PB5,PB6,PB7,PB8,PB9脚

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;	//DATA
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	   
	GPIO_Init(GPIOC, &GPIO_InitStructure);//数据引脚是GPIOC的PC0~PC7脚

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;	// LCD_LIGHT即PB13
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	   
	GPIO_Init(GPIOB, &GPIO_InitStructure);
}



   
/****************************************************************************
* 名    称：void DispSmallPic(u16 x, u16 y, u16 w, u16 h, const u8 *str)
* 功    能：再指定位置显示一张图片
* 入口参数：x:x轴坐标  y：y坐标  w：宽  h：高  str:像素 
* 出口参数：无
* 说    明：2012.5.8 hxm  v1.0
* 调用方法：无 
****************************************************************************/
void DispSmallPic(uint x, uint y, uint w, uint h, const uchar *str)
{ 
    uint i,j;
    for(j=0;j<h;j++)
    {
        Set_ramaddr(x,y+j);
        write_cmd(0X2C);
        for(i=0;i<w;i++)
        {       
            write_data8(str[(j*w+i)*2+1]);     //低位在前
            write_data8(str[(j*w+i)*2]);
        }
    }
}
/****************************************************************************
* 名    称：void GUI_Disphz(u8 *hz);
* 功    能：在当前位置显示一个中文字符16*16
* 入口参数：*hz字符，正反显函数有效。
* 出口参数：无
* 说    明：2012.5.3 hxm  v1.0
* 调用方法：无 
****************************************************************************/
void GUI_Disphz(uchar *hz)
{
	GUI_DisphzAt(hz, posX, posY);
	GUI_GetPos(2);	
}

 /******

 从SPT手持机调用的LCD显示程序
 区位码  标准字库模式

 *******/


 //生成颜色数据
void bs_color_set(uint wr_color,uint blank_color)
{
    LCD_PART.color[0] = wr_color/16;                         //A0A1
    LCD_PART.color[1] = wr_color*16 + wr_color/256;          //A2A0
    LCD_PART.color[2] = wr_color;                            //A1A2
    LCD_PART.color[3] = wr_color*16 + blank_color/256;       //A2B0
    LCD_PART.color[4] = blank_color/16;                      //B0B1
    LCD_PART.color[5] = blank_color*16 + blank_color/256;    //B2B0
    LCD_PART.color[6] = blank_color;                         //B1B2
    LCD_PART.color[7] = blank_color*16 + wr_color/256;       //B2A0
}
//显示指定位置汉字和字符
void apoint_place_write(uchar s_column,uchar s_row,uchar *wr_sp,uint w_color,uint bk_color)
{
    uchar tempa,tempb,number=0;
    
    bs_color_set(w_color,bk_color);
    while((*wr_sp != 0)&&(number < 20))                                         //检测到结束标示退出
    {
        if(*wr_sp < 0x80)                                                       //ASCII字符写操作
        {
            GUI_DispCharAt(wr_sp,s_column,s_row);                                   //过滤掉空格
            wr_sp++;
            s_column += 8;
        }
        else                                                                    //汉字写
        {
            if(*wr_sp == 0xff)                                                  //写特殊字符
            {
                wr_sp++;
                tempa = *wr_sp&0xf0;
                if(tempa == 0xa0)
                {
                    tempb = *wr_sp&0x0f;
                    //signal_write(s_column,s_row,tempb,SIGNAL_SN);
                    s_column += 16;
                }
                else
                {
                    if(tempa == 0xe0)
                    {
                        tempb = *wr_sp&0x0f;
                        //signal_write(s_column,s_row,tempb,CHARGE_SN);
                        s_column += 16;
                    }
                }
                wr_sp++;
            }
            else
            {
                if(*wr_sp >= 0x4e)
                {
                    GUI_DisphzAt(wr_sp,s_column,s_row);
                    wr_sp += 2;
                    s_column += 16;
                }
                else
                    wr_sp++;                                                                        //过滤掉无效的字符
            }
        }
        number++;
    }
    //BUS_DATA_IN;
}

 //通用写操作
void often_show(uchar s_column,uchar s_row,const uchar show_buf[32],uint wr_color,uint blank_color)
{
    //GUI_Clear(White);
    apoint_place_write(s_column,s_row,(uchar*)show_buf,wr_color,blank_color);
}




/****************************************************************************
* 名    称：void GUI_DisphzAt(u8 *hz, u16 x, u16 y);
* 功    能：在指定位置显示一个中文字符16*16
* 入口参数：*hz字符x轴位置y轴位置,正反显函数有效。
* 出口参数：无
* 说    明：2012.5.2 hxm  v1.0
* 调用方法：无 
*显示一个汉字的函数
****************************************************************************/
void GUI_DisphzAt(uchar hz_sp[], uint x, uint y)
{

	ulong tempaddr;
	uchar tempa,tempb;
	uint j=0,i=0,k=0;
	uint str,len;
	uint GetColor,GetBKColor;
	uint temp1, temp2, temp3, temp4;

	uchar info_buf[2];
	info_buf[0]	=hz_sp[0];
	info_buf[1] =hz_sp[1];
	if(x>112||y>144)return;
		
	if(GUI_SetDrawMode==1)
	{GetColor=GUI_GetColor;GetBKColor=GUI_GetBKColor;}
	else
	{GetColor=GUI_GetBKColor;GetBKColor=GUI_GetColor;}

	temp1 =  GetColor >> 8;
	temp2 =  GetColor & 0x00ff;
	temp3 =  GetBKColor >> 8;
	temp4 =  GetBKColor & 0x00ff;
                                         

//---------------------------查找是否在字库中出现 
	len=sizeof(HZ)/sizeof(HZ[0]);  
 	for(j=0;j<len;j++)
	{
    if(((uchar)HZ[j].Index[0]==info_buf[0])&&((uchar)HZ[j].Index[1]==info_buf[1]))	
		break;
	}
//--------------------------      
	if(j<len)
	{
			for (i=0;i<16;i++)
			{
				 Set_ramaddr(x,y+i);
				 write_cmd(0X2C);

				 str = (u8)HZ[j].Msk[i*2]<<8|(u8)HZ[j].Msk[i*2+1];

					for (k=0;k<16;k++)
					{
							if ( str & (0x8000>>k) )     //0x8000>>k
							{
								write_data8(temp1);
								write_data8(temp2);
							}
							else
							{                   
								write_data8(temp3);
								write_data8(temp4);                                                                                  
							}               
					} 
			}
	}
	posX=x;
	posY=y;
	GUI_GetPos(2);
}


/***
特殊操作，显示管理员或者管理单位的信息
op_Buff[]最长为16个字节
不需要在字库中取模操作
***/

void  Test_ShowOp(void)
{
	
const char ttt[] ={0x10,0x00,0x08,0x00,0x08,0x04,0x7E,0xFE,0x04,0x24,0x08,0x24,0x12,0x24,0x34,0x24,
                   0x58,0x24,0x94,0x24,0x12,0x44,0x10,0x44,0x10,0x84,0x11,0x14,0x12,0x08,0x00,0x00,//"初",
                   0x10,0x20,0x18,0x30,0x10,0x20,0x10,0x48,0xFC,0x84,0x25,0xFE,0x24,0x84,0x44,0x00,
                   0x44,0xFC,0x28,0x84,0x18,0x84,0x14,0x84,0x22,0x84,0x42,0xFC,0x80,0x84,0x00,0x00,//"始",//"化"
                   0x08,0x80,0x0C,0x80,0x08,0x88,0x10,0x8C,0x10,0x98,0x30,0xB0,0x50,0xE0,0x90,0xC0,
                   0x11,0x80,0x12,0x80,0x14,0x80,0x10,0x84,0x10,0x84,0x10,0x84,0x10,0x7C,0x00,0x00
                  };
	Show_Operater(0,0,(uchar*)ttt,3,0,0x0fff);
  while(1);
	
}
void Show_Operater(uchar s_column,uchar s_row,uchar op_Buff[],uchar len,uint wr_color,uint blank_color)
{
  ulong tempaddr;
	uint  tempa_downaddr;
  uchar tempa,tempb;
	uint j=0,i=0,k=0,x=0,y=0;
	uint str;
	uint GetColor,GetBKColor;
	uint temp1, temp2, temp3, temp4;
	x=s_column;
	y=s_row;
	
	if(GUI_SetDrawMode==1)
	{GetColor=GUI_GetColor;GetBKColor=GUI_GetBKColor;}
	else
	{GetColor=GUI_GetBKColor;GetBKColor=GUI_GetColor;}

	temp1 =  GetColor >> 8;
	temp2 =  GetColor & 0x00ff;
	temp3 =  GetBKColor >> 8;
	temp4 =  GetBKColor & 0x00ff;
  for(j =0;j<len;j++)
  
    {
			  tempa_downaddr =32*j;
        for (i=0;i<16;i++)
        {
             Set_ramaddr(x,y+i);		//改变显存地址
             write_cmd(0X2C);		//显存写命令，后面跟数据
             str = op_Buff[tempa_downaddr+i*2]<<8|op_Buff[tempa_downaddr+i*2+1];
             for (k=0;k<16;k++)
            {
                if ( str & (0x8000>>k) )     //0x8000>>k，先写最高位，如果是1，写字的颜色
                {
                    write_data8(temp1);
		                write_data8(temp2);
                }
                else		//如果是0，写背景色
                {                   
                    write_data8(temp3);
		                write_data8(temp4);                                                                                  
                }               
            } 
        }
        x=x+16;		//列加16
				y=y;
				if(x>114)   //换行显示
				{
					x =0;
					y=y+16;
				}
				
	   
	 }
	
	
}
//显示一个字符串
void GUI_DispString(uchar str[],uchar len)
{
  uchar i;
  for(i =0;i<len;i++)
  {
    GUI_DispChar(str[i]);
  }
  
  
}
/****************************************************************************
* 名    称：void GUI_DispChar(u8 *ASCii);
* 功    能：在当前位置显示一个字符
* 入口参数：*ASCii字符,正反显函数有效。
* 出口参数：无
* 说    明：2012.5.3 hxm  v1.0
* 调用方法：无 
*显示一个字符的函数

****************************************************************************/
void GUI_DispChar(uchar ASCii)
{
	//GUI_DispCharAt(ASCii,posX,posY);
	GUI_GetPos(1);	
}
/****************************************************************************
* 名    称：void GUI_GetPos(void);
* 功    能：计算当前文字输入所达位置
* 入口参数：
* 出口参数：
* 说    明：2012.5.3 hxm  v1.0
* 调用方法： 

****************************************************************************/
void GUI_GetPos(uint font)
{
	posX=font*8+posX;		//posX是一个全局变量，表示别，8表示一个数字的宽度
	if(posX>=128)
	{
	 posX=16+posY; 
	}
	if(posY>=160)
	{
	 posY=0;
	 posX=0;
	}	
}
/****************************************************************************
* 名    称：void GUI_DispCharAt(u8 *ASCii, u16 x, u16 y);
* 功    能：在指定位置显示一个ASCII字符
* 入口参数：*ASCii字符x轴位置y轴位置,正反显函数有效。
* 出口参数：无
* 说    明：2012.5.2 hxm  v1.0
* 调用方法：无 
*显示一个字符的函数
*将乘法的模式改为 左移 
****************************************************************************/
void GUI_DispCharAt(uchar *char_sp, uint x, uint y)
{
   
	uint j=0,i=0,k=0;
	uint str,len;
	uint GetColor,GetBKColor;
	uint temp1, temp2, temp3, temp4;
  ulong tempaddr;
	uchar *r_sp;
	uchar info_buf[16];
	tempaddr = *char_sp;
	if(x>120||y>144)return;

	if(GUI_SetDrawMode==1)
	{GetColor=GUI_GetColor;GetBKColor=GUI_GetBKColor;}
	else
	{GetColor=GUI_GetBKColor;GetBKColor=GUI_GetColor;}

	temp1 =  GetColor >> 8;
	temp2 =  GetColor & 0x00ff;
	temp3 =  GetBKColor >> 8;
	temp4 =  GetBKColor & 0x00ff;
  len=sizeof(codeASCII)/sizeof(codeASCII[0]);
   
 	for(j=0;j<len;j++)
	{
		 if((uchar)codeASCII[j].Index[0]==char_sp[0])	  //指针的运用，主要是查内码
		 break;
	}

      
	if(j<len)
	{
			for (i=0;i<16;i++)
			{
					Set_ramaddr(x,y+i);
					write_cmd(0X2C);

					str = (uchar)codeASCII[j].Msk[i];		//使用内码所关联的字模


					for (k=0;k<8;k++)
					{
							if ( str & (0x80>>k) )     
							{
									write_data8(temp1);
									write_data8(temp2);
							}
							else
							{                   
									write_data8(temp3);
									write_data8(temp4);                                                                                  
							}               
					} 
			}
	 }
	posX=x;
	posY=y;
	//GUI_GetPos(1);
}


/****************************************************************************
* 名    称：void Set_ramaddr(u16 x,u16 y)
* 功    能：指定坐标点
* 入口参数：x轴y轴
* 出口参数：无
* 说    明：2012.4.27 hxm  v1.0
* 调用方法：无 
****************************************************************************/ 					  
void Set_ramaddr(uchar x,uchar y)
{
	write_cmd(0x2a);
	write_data8(0x00);
	write_data8(x);

	write_cmd(0x2b);
	write_data8(0x00);
	write_data8(y);
}

/*void lcd_reset(void)
{
   LCD_RST_DIS;		//置位ＰＢ５，ＰＢ５接的是ＬＣＤ＿ＲＳＴ
   Delay(5);
   LCD_RST_EN;		//复位PB5，看来LCD_RST是低电平有效
   Delay(2);
   LCD_RST_DIS;	
   Delay(12);
 }*/


unsigned char read ()
{
 
 return 0;
}

void ReadID()
{	
	
	

	
}


void writePixel(uchar x_start,uchar y_start,uint color)

{
	write_cmd(0x2a);
	write_data8(0x00);
	write_data8(x_start);
	write_data8(0x00);
	write_data8(x_start);
	write_cmd(0x2b);
	write_data8(0x00);
	write_data8(y_start);
	write_data8(0x00);
	write_data8(y_start);
	write_cmd(0x2c);
	write_data8(color>>8);
	write_data8(color&0xff);
	
	
}


/*左上角点（先列后行），右上角点（先列后行）*/
void adress_set(uchar x_start,uchar y_start,uchar x_end,uchar y_end)
{
	write_cmd(0x2a);
	write_data8(0x00);
	write_data8(x_start);
	write_data8(0x00);
	write_data8(x_end);
	
	write_cmd(0x2b);
	write_data8(0x00);
	write_data8(y_start);
	write_data8(0x00);
	write_data8(y_end);
	write_cmd(0x2c);


	
}

void GUI_Clear(uint color)
{ 
	uchar i,j;
	uint temp1,temp2;
	adress_set(0,0,127,159);
	write_cmd(0X2C);		//Memory write
	temp1=color>>8;
	temp2=color&0x00ff;
	for(i=0;i<128;i++)
	{
	 for(j=0;j<160;j++)
	 {
	  write_data8(temp1);
	  write_data8(temp2);
	 }
	} 
}

void GUI_Clear2(uint col_s,uint row_s,uint col_e,uint row_e,uint color)
{ 
	uchar i,j;
	uint temp1,temp2;
	adress_set(col_s,row_s,col_e,row_e);
	write_cmd(0X2C);		//Memory write
	temp1=color>>8;
	temp2=color&0x00ff;
	for(i=0;i<=row_e-row_s;i++)
	{
	 for(j=0;j<=col_e-col_s;j++)
	 {
	  write_data8(temp1);
	  write_data8(temp2);
	 }
	} 
}





static char hex2ch(char hex)
{
	return asc_table[hex];
}

/*
显示十六进制
先列后行
*/
void print_hex(uint x0, uint y0,uchar ForeColor, uchar hex)
{
  
	int i;
	
	uchar table[4];

	table[0] = '0';
	table[1] = 'x';
	table[2] = hex2ch(hex >> 4);
	table[3] = hex2ch(hex & 0x0f);
	
	for (i = 0;i < 4;i++)
	{
		 GUI_DispCharAt_Test(table[i],x0+i*8,y0);
	}
  
}


/*
显示二进制
先行后列
*/

void DisplayHNumber(unsigned int x0, unsigned int y0, unsigned int color, unsigned char s)
{
   unsigned char  i,k;
   k=s;

	for(i=0;i<8;i++)
	{  
			if((k&0x80)==0x80)
			{
				//DisplayNumber( x0+i*10,y0,color,1);
				GUI_DispCharAt_Test('1',x0+i*10,y0);
			}
			else
			{
				//DisplayNumber( x0+i*10,y0,color,0);
				GUI_DispCharAt_Test('0',x0+i*10,y0);				
			}
			k=k<<1;
  }
	
}




void DisplayNumber(unsigned int x0, unsigned int y0, unsigned int color, unsigned char s)
{
  uchar ge,shi,bai;
	bai=s/100+48;
	shi=s%100/10+48;
	ge=s%10+48;
	
	if(s>=100&&y0<136)
	{
		GUI_DispCharAt_Test(bai,x0,y0);
		GUI_DispCharAt_Test(shi,x0+8,y0);		
		GUI_DispCharAt_Test(ge,x0+16,y0);
	}
	else if(s<100&&s>=10&&y0<144) 
	{
		GUI_DispCharAt_Test(shi,x0,y0);		
		GUI_DispCharAt_Test(ge,x0+8,y0);
	}
	else
	{
		GUI_DispCharAt_Test(ge,x0,y0);
	}
		
}

void display_shuzi(uchar s_column,uchar s_row,uchar *wr_sp,uint w_color,uint bk_color)
{
	
		uchar table[8];
		uint8_t i,j;
	
		j=0;
		for(i=0;i<4;i++)
		{

			table[j] = hex2ch(wr_sp[i] >> 4);
			j++;
			table[j] = hex2ch(wr_sp[i] & 0x0f);		
			j++;
		}
		
		apoint_place_write(s_column,s_row,(uchar*)table,w_color,bk_color);


}

void display_shuzi_zijie(uchar s_column,uchar s_row,uchar *wr_sp,uint w_color,uint bk_color)
{
	
		uchar table[4];
		uint8_t i,j;
	
		j=0;
		for(i=0;i<2;i++)
		{

			table[j] = hex2ch(wr_sp[i] >> 4);
			j++;
			table[j] = hex2ch(wr_sp[i] & 0x0f);		
			j++;
		}
		
		apoint_place_write(s_column,s_row,(uchar*)table,w_color,bk_color);


}


void show_pure_image(unsigned char DataH,unsigned char DataL)
{
  int i,j;
  adress_set(0,0,127,127);

  for(i=128;i>0;i--)
  {
   for(j=128;j>0;j--)
   {
   	 write_data8(DataH);
	 write_data8(DataL);
	
	}
  }

}


void display_gray()
{
	
	
		uint a;
		int i,j,k;

		adress_set(0,0,127,159);	
    for(i=0;i<80;i++)
     {
        for(j=0;j<16;j++)
         {
            for(k=0;k<8;k++)
           {
              a=0xffff-0x1082*j;
							write_data8(a>>8);
              write_data8(a);
           }
          }
 
       }

		for(i=0;i<80;i++)
		{
			for(j=0;j<16;j++)
			 {
					for(k=0;k<8;k++)
				 {
						a=0x0000+0x1082*j;
						 write_data8(a>>8);
						 write_data8(a);
					 }
				 }
		}
}


void show_H_bar(void)
{
 int i,j;
 for(i=128;i>0;i--)
  for(j=128;j>0;j--)
   if(i%2==0)
     {write_data8(0xff);write_data8(0xff);}
   else
     {write_data8(0x00);write_data8(0x00);}
}

void show_V_bar(void)
{
 int i,j;
 for(i=128;i>0;i--)
  for(j=128;j>0;j--)
   if(j%2==0)
     {write_data8(0xff);write_data8(0xff);}
   else
     {write_data8(0x00);write_data8(0x00);}
}


void show_frame(void)
{
 int i,j;
 for(i=160;i>0;i--)
  for(j=128;j>0;j--)
   if(i==1||i==160||j==1||j==128)
    {write_data8(0xff);
     write_data8(0xff);}
   else
     {write_data8(0x00);
     write_data8(0x00);}     
}

void show_cs_open(void)
{
int i,j;
 for(i=160;i>0;i--)
  for(j=128;j>0;j--)
   if((i+j)%2==0)
    {write_data8(0xff);
     write_data8(0xff);}
   else
     {write_data8(0x00);
     write_data8(0x00);}    
}


 /****************************************************************************
* 名    称：void GUI_DispCharAt(u8 *ASCii, u16 x, u16 y);
* 功    能：在指定位置显示一个字符
* 入口参数：*ASCii字符x轴位置y轴位置,正反显函数有效。
* 出口参数：无
* 说    明：2012.5.2 hxm  v1.0
* 调用方法：无 
****************************************************************************/
void GUI_DispCharAt_Test(uchar ASCii, uint x, uint y)
{
	uint j=0,i=0,k=0;
	uint str,len;
	uint GetColor,GetBKColor;
	uint temp1, temp2, temp3, temp4;

	if(x>120||y>144)return;

	if(GUI_SetDrawMode==1)
	{GetColor=GUI_GetColor;GetBKColor=GUI_GetBKColor;}
	else
	{GetColor=GUI_GetBKColor;GetBKColor=GUI_GetColor;}

	temp1 =  GetColor >> 8;
	temp2 =  GetColor & 0x00ff;
	temp3 =  GetBKColor >> 8;
	temp4 =  GetBKColor & 0x00ff;
 
       len=sizeof(codeASCII)/sizeof(codeASCII[0]);
   
 	for(j=0;j<len;j++)
        {
         if((uchar)codeASCII[j].Index[0]==ASCii)	
	 break;
        }
      
    if(j<len)
    {
        for (i=0;i<16;i++)
        {
            Set_ramaddr(x,y+i);
            write_cmd(0X2C);

            str = (uchar)codeASCII[j].Msk[i];

            for (k=0;k<8;k++)
            {
                if ( str & (0x80>>k) )     
                {
                    write_data8(temp1);
		    write_data8(temp2);
                }
                else
                {                   
                    write_data8(temp3);
	            write_data8(temp4);                                                                                  
                }               
            } 
        }
    }
	posX=x;
	posY=y;
	//GUI_GetPos(1);
}


/* 显示图片或图标  */
void show_picture1(uint8_t start_col ,uint8_t start_row,uint8_t end_col ,uint8_t end_row,uint8_t * pic)
{
  
  int i,j,k;
  k=0x00;
	
  adress_set(start_col,start_row,end_col,end_row);

	for(i=start_row;i<=end_row;i++)
		for(j=start_col;j<=end_col;j++)   
		{  
				write_data8(pic[k++]);
				write_data8(pic[k++]); 
		 }
  
}

// void show_picture2()
// {
//   
//   int i,j,k;
//   k=0x00;
//   adress_set(0,0,127,127);
//   for(i=80;i>0;i--)
//    for(j=128;j>0;j--)
//    {  
//     write_data8(picture2[k++]);
//     write_data8(picture2[k++]); 
//    }
//   
// }

void lcd_init(void)	
{ 
//#if (LCD==tianma)

  write_cmd(0x11);
  Delay(20);
   
	
	write_cmd(0xB1); //帧率控制
	write_data8(0x01);  
	write_data8(0x2C);
	write_data8(0x2D);

	write_cmd(0xB2);
	write_data8(0x01);  
	write_data8(0x2C);
	write_data8(0x2D);

	write_cmd(0xB3);
	write_data8(0x01);   
	write_data8(0x2C);
	write_data8(0x2D);
	write_data8(0x01);
	write_data8(0x2C);
	write_data8(0x2D);
	
	write_cmd(0xB4); 
	write_data8(0x03); 	
	
	write_cmd(0xB6);   
	write_data8(0xB4); 
	write_data8(0xF0); 
	
	write_cmd(0xC0);
	write_data8(0xA2);
	write_data8(0x02);
	write_data8(0x84);

	write_cmd(0xC1);
	write_data8(0xC5);

	write_cmd(0xC2);
	write_data8(0x0A);
	write_data8(0x00);

	write_cmd(0xC3);
	write_data8(0x8A);
	write_data8(0x2A);

	write_cmd(0xC4);
	write_data8(0x8A);
	write_data8(0xEE);
	
	write_cmd(0xC5); 
	write_data8(0x0A);   
	
	write_cmd(0x36); //MX, MY, RGB mode
	write_data8(0xC8);   //0x68
	
	write_cmd(0xe0);
	write_data8(0x02);
	write_data8(0x1c);
	write_data8(0x07);
	write_data8(0x12);
	write_data8(0x37);
	write_data8(0x32);
	write_data8(0x29);
	write_data8(0x2d);
	write_data8(0x29);
	write_data8(0x25);
	write_data8(0x2b);
	write_data8(0x39);
	write_data8(0x00);
	write_data8(0x01);
	write_data8(0x03);
	write_data8(0x10);
	
	write_cmd(0xe1);
	write_data8(0x03);
	write_data8(0x1d);
	write_data8(0x07);
	write_data8(0x06);
	write_data8(0x2e);
	write_data8(0x2c);
	write_data8(0x29);
	write_data8(0x2d);
	write_data8(0x2e);
	write_data8(0x2e);
	write_data8(0x37);
	write_data8(0x3f);
	write_data8(0x00);
	write_data8(0x00);
	write_data8(0x02);
	write_data8(0x10);
	
	write_cmd(0x2a);
	write_data8(0x00);
	write_data8(0x00);
	write_data8(0x00);
	write_data8(0x7f);
		  
	write_cmd(0x2b);
	write_data8(0x00);
	write_data8(0x00);
	write_data8(0x00);
	write_data8(0x9f);
	
	write_cmd(0xF0); 
	write_data8(0x01);
	write_cmd(0xF6); 
	write_data8(0x00);
	
	write_cmd(0x3A); //65k mode
	write_data8(0x05);
	//write_data8(0x06);//256K 颜色位有待商榷	
	write_cmd(0x29); //Display on
  /** 
  write_cmd(0xb1);
  write_data8(0x01);
  write_data8(0x35);
  write_data8(0x36);

  write_cmd(0xb2);
  write_data8(0x02);
  write_data8(0x35);
  write_data8(0x36);

  write_cmd(0xb3);
  write_data8(0x02);
  write_data8(0x35);
  write_data8(0x36);
  write_data8(0x02);
  write_data8(0x35);
  write_data8(0x36);

  write_cmd(0xb4);
  write_data8(0x03);
  
 // write_cmd(0xb6);
 // write_data8(0x84);
 // write_data8(0xf0);
 // write_data8(0x20);
    
  write_cmd(0xc0);
  write_data8(0xa2);
  write_data8(0x02);
  write_data8(0x84);
   
  write_cmd(0xc1);
  write_data8(0xc5);

  write_cmd(0xc2);
  write_data8(0x0d);
  write_data8(0x00);

  write_cmd(0xc3);
  write_data8(0x8a);
  write_data8(0x2a);

  write_cmd(0xc4);
  write_data8(0x8a);
  write_data8(0xee);
   
  write_cmd(0xc5);
  write_data8(0x03);
  
  
  write_cmd(0xe0);
  write_data8(0x12);
  write_data8(0x1c);
  write_data8(0x10);
  write_data8(0x18);
  write_data8(0x33);
  write_data8(0x2c);
  write_data8(0x25);
  write_data8(0x28);
  write_data8(0x28);
  write_data8(0x27);
  write_data8(0x2f);
  write_data8(0x3c);
  write_data8(0x00);
  write_data8(0x03);
  write_data8(0x03);
  write_data8(0x10); 
 
  write_cmd(0xe1);
  write_data8(0x12);
  write_data8(0x1d);
  write_data8(0x10);
  write_data8(0x18);
  write_data8(0x2d);
  write_data8(0x28);
  write_data8(0x23);
  write_data8(0x28);
  write_data8(0x28);
  write_data8(0x26);
  write_data8(0x2f);
  write_data8(0x3b);
  write_data8(0x00);
  write_data8(0x03);
  write_data8(0x03);
  write_data8(0x10);
  write_cmd(0x36);
  write_data8(0xc8);
  
 
  write_cmd(0xf0);
  write_data8(0x01);
  write_cmd(0xf6);
  write_data8(0x00);
 
  write_cmd(0x3a);
  write_data8(0x05);
  
  write_cmd(0x29);
  write_cmd(0x2c);
  ***/


			
}


void LCD_init2(void)
{
//  uchar j,i; 

	write_cmd(0x01);   //软件复位
	Delay(5);
	Delay(20);
	write_cmd(0x11);//SLEEP OUT
	Delay(20);
	Delay(20);

	write_cmd(0xFF);
	write_data8(0x40);
	write_data8(0x03);
	write_data8(0x1A);

	write_cmd(0xd9);      
	write_data8(0x60);
	write_cmd(0xc7);
	write_data8(0x90);
	Delay(20);

	write_cmd(0xB1);
	write_data8(0x04);
	write_data8(0x25);
	write_data8(0x18);

	write_cmd(0xB2);
	write_data8(0x04);
	write_data8(0x25);
	write_data8(0x18);

	write_cmd(0xB3);
	write_data8(0x04);
	write_data8(0x25);
	write_data8(0x18);
	write_data8(0x04);
	write_data8(0x25);
	write_data8(0x18);

	write_cmd(0xB4);
	write_data8(0x03);

	write_cmd(0xB6);
	write_data8(0x15);
	write_data8(0x02);

	write_cmd(0xC0);// POWER CONTROL 1 GVDD&VCI1
	write_data8(0x02);
	write_data8(0x70);

	write_cmd(0xC1);// POWER CONTROL 2 GVDD&VCI1
	write_data8(0x07);

	write_cmd(0xC2);// POWER CONTROL 3 GVDD&VCI1
	write_data8(0x01);
	write_data8(0x01);

	write_cmd(0xC3);// POWER CONTROL 4 GVDD&VCI1
	write_data8(0x02);
	write_data8(0x07);

	write_cmd(0xC4);// POWER CONTROL 5 GVDD&VCI1
	write_data8(0x02);
	write_data8(0x04);

	write_cmd(0xFC);// POWER CONTROL 6 GVDD&VCI1
	write_data8(0x11);
	write_data8(0x17);

	write_cmd(0xC5);//VCOMH&VCOML
	write_data8(0x3c);
	write_data8(0x4f);

	write_cmd(0x36);//MV,MX,MY,RGB
	write_data8(0xC8); 


	write_cmd(0x3a);//GAMMA SET BY REGISTER
	write_data8(0x05);

	//***********************GAMMA*************************
	write_cmd(0xE0);
	write_data8(0x06);
	write_data8(0x0E);
	write_data8(0x05);
	write_data8(0x20);
	write_data8(0x27);
	write_data8(0x23);
	write_data8(0x1C);
	write_data8(0x21);
	write_data8(0x20);
	write_data8(0x1C);
	write_data8(0x26);
	write_data8(0x2F);
	write_data8(0x00);
	write_data8(0x03);
	write_data8(0x00);
	write_data8(0x24);

	write_cmd(0xE1);
	write_data8(0x06);
	write_data8(0x10);
	write_data8(0x05);
	write_data8(0x21);
	write_data8(0x27);
	write_data8(0x22);
	write_data8(0x1C);
	write_data8(0x21);
	write_data8(0x1F);
	write_data8(0x1D);
	write_data8(0x27);
	write_data8(0x2F);
	write_data8(0x05);
	write_data8(0x03);
	write_data8(0x00);
	write_data8(0x3F);

	//***************************RAM ADDRESS*******************
	write_cmd(0x2A);
	write_data8(0x00);
	write_data8(0x02);
	write_data8(0x00);
	write_data8(0x81);

	write_cmd(0x2B);
	write_data8(0x00);
	write_data8(0x03);
	write_data8(0x00);
	write_data8(0x82);

	write_cmd(0x29);
	Delay(10);

	write_cmd(0x2C);
                             //初始化结束
  /**
  for (i=0;i<128;i++)
    {
    for (j=0;j<128;j++)
       {
           write_data8(0xf8);
	   write_data8(0x00);  //display red
        }
     }
	 **/

}

void Lcd_Init3(void)
{
	write_cmd(0x11);
	Delay(20);
 
   
  write_cmd(0xb1);
  write_data8(0x02);
  write_data8(0x35);
  write_data8(0x36);

  write_cmd(0xb2);
  write_data8(0x02);
  write_data8(0x35);
  write_data8(0x36);

  write_cmd(0xb3);
  write_data8(0x02);
  write_data8(0x35);
  write_data8(0x36);
  write_data8(0x02);
  write_data8(0x35);
  write_data8(0x36);

  write_cmd(0xb4);
  write_data8(0x03);
  

  write_cmd(0xc0);
  write_data8(0xa2);
  write_data8(0x02);
  write_data8(0x84);
   
  write_cmd(0xc1);
  write_data8(0xc5);

  write_cmd(0xc2);
  write_data8(0x0d);
  write_data8(0x00);

  write_cmd(0xc3);
  write_data8(0x8a);
  write_data8(0x2a);

  write_cmd(0xc4);
  write_data8(0x8a);
  write_data8(0xee);
   
  write_cmd(0xc5);
  write_data8(0x03);
  
  
  write_cmd(0xe0);
  write_data8(0x12);
  write_data8(0x1c);
  write_data8(0x10);
  write_data8(0x18);
  write_data8(0x33);
  write_data8(0x2c);
  write_data8(0x25);
  write_data8(0x28);
  write_data8(0x28);
  write_data8(0x27);
  write_data8(0x2f);
  write_data8(0x3c);
  write_data8(0x00);
  write_data8(0x03);
  write_data8(0x03);
  write_data8(0x10); 
 
  write_cmd(0xe1);
  write_data8(0x12);
  write_data8(0x1d);
  write_data8(0x10);
  write_data8(0x18);
  write_data8(0x2d);
  write_data8(0x28);
  write_data8(0x23);
  write_data8(0x28);
  write_data8(0x28);
  write_data8(0x26);
  write_data8(0x2f);
  write_data8(0x3b);
  write_data8(0x00);
  write_data8(0x03);
  write_data8(0x03);
  write_data8(0x10);
  write_cmd(0x36);
  write_data8(0xc8);
  
 
  write_cmd(0xf0);
  write_data8(0x01);
  write_cmd(0xf6);
  write_data8(0x00);
 
  write_cmd(0x3a);
  write_data8(0x05);
  
  write_cmd(0x29);
  write_cmd(0x2c);


}
 /****
  测试LCD显示的函数

 *****/
void Test_Plcd(void)
{
   //uchar i,j;
   //lcd_reset();

   //lcd_init();
   //LCD_init2();
   Lcd_Init3();
   Delay(20);
	
   GUI_Clear(White);
   GUI_DispCharAt_Test('a',0,0);
   //often_show(36,56,"初始化中...",0,0x0fff);
   while(1);

}



 /**
  主界面LCD显示内容
       显示时间：
      年月日 时分秒
      用户的编号：

 time_buff[0] =date_s.year;
 time_buff[1] =date_s.month;
 time_buff[2] =date_s.day;
 time_buff[3] =date_s.hour;
 time_buff[4] =date_s.min;
 time_buff[5] =date_s.sec;
 主界面显示内容
 2014年05月05日
 10时59分59秒
 惠和科技
 电子智能钥匙
 时 --65F6
 分 --5206
 秒 --79D2
 **/
void Main_Lcd_Show(void)
{
  uchar i,keycode;
	//void apoint_place_write(uchar s_column,uchar s_row,uchar *wr_sp,uint w_color,uint bk_color)
	//apoint_place_write(0,0,"信号",0,0xfff);  //
	
	//apoint_place_write(96,0,"电量",0,0xfff);  //

  Lcd_Clear(0);	
 	//apoint_place_write(48,48," ",0,0x0fff);
  apoint_place_write(32,70,"钥匙",0,0x0fff);
	
	apoint_place_write(0,144,"工具",0,0x0fff);
	apoint_place_write(96,144,"设置",0,0x0fff);
	keycode=ReadData(KEY_ENCODE);
	DisplayNumber(68,70,0,keycode);
	for(i=0;i<8;i++)
	{
	zuming[i]=ReadData(AUTHOR_START+16+i);
	}
	zuming1[0]=zuming[0];
	zuming1[1]=zuming[1];
	zuming2[0]=zuming[2];
	zuming2[1]=zuming[3];
	zuming3[0]=zuming[4];
	zuming3[1]=zuming[5];
	zuming4[0]=zuming[6];
	zuming4[1]=zuming[7];
	GUI_DisphzAt(zuming1,32,48);
	GUI_DisphzAt(zuming2,48,48);
	GUI_DisphzAt(zuming3,64,48);
	GUI_DisphzAt(zuming4,80,48);
	if(Power_Cheak() ==0)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt0);	
					}
			else if(Power_Cheak() ==1)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt3);
					}
			     else if(Power_Cheak() ==2)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt1);	
					}
			          else if(Power_Cheak() ==3)
					{
				  show_picture1(0,0,31,15,lcd_buf_batt2);	
					}
					
 			 if((USB_CHEAK&(GPIO_Pin_12))!=0)  //USB_CHEAK ==(GPIO_Pin_12)
			{
				show_picture1(96,0,127,15,lcd_buf_signal);
      }
			else if((USB_CHEAK&(GPIO_Pin_12))==0)
			{
				show_picture1(96,0,127,15,lcd_buf_nosignal);
      }
	//show_picture1(0,0,31,15,lcd_buf_batt0);
 	//show_picture1(96,0,127,15,lcd_buf_signal);
	
 	//apoint_place_write(32,0,lcd_buf2,0,0x0fff);	
}




void Main_Lcd_Show2(void)
{
	uchar  tempa;
  uchar  lcd_buf[15],lcd_buf1[15];		//lcd_buf存年月日，lcd_buf1存时分秒
  read_time();  //读取实时时间,放到time_buffer中 //2015-4-21 by xiaolong
	lcd_buf[0] = '2';
	lcd_buf[1] = '0';
	tempa = (time_buff[0]>>4)&0x0f;
	lcd_buf[2] = tempa+0x30;		//转化为字符
	tempa = (time_buff[0]&0x0f);
	lcd_buf[3] = tempa + 0x30;
	lcd_buf[4] = 0xc4;
	lcd_buf[5] = 0xea;   //年的内码
	tempa = (time_buff[1]>>4)&0x0f;
	lcd_buf[6] = tempa+0x30;
	tempa = time_buff[1]&0x0f;
	lcd_buf[7] = tempa+0x30;
	lcd_buf[8] = 0xd4;
	lcd_buf[9] = 0xc2;   //月的内码
	tempa = (time_buff[2]>>4)&0x0f;
	lcd_buf[10] = tempa+0x30;
	tempa = time_buff[2]&0x0f;
	lcd_buf[11] = tempa+0x30;
	lcd_buf[12] = 0xc8;
	lcd_buf[13] = 0xd5;   //日的内码
	lcd_buf[14] = 0;   //结束标志

	tempa = (time_buff[3]>>4)&0x0f;
	lcd_buf1[0] = tempa+0x30;
	tempa = time_buff[3]&0x0f;
	lcd_buf1[1] = tempa + 0x30;
	lcd_buf1[2] = 0xCA;
	lcd_buf1[3] = 0xB1;   //时
	tempa = (time_buff[4]>>4)&0x0f;
	lcd_buf1[4] = tempa+0x30;
	tempa = time_buff[4]&0x0f;
	lcd_buf1[5] = tempa+0x30;
	lcd_buf1[6] = 0xb7;
	lcd_buf1[7] = 0xd6;   //分
	tempa = (time_buff[5]>>4)&0x0f;
	lcd_buf1[8] = tempa+0x30;
	tempa = time_buff[5]&0x0f;
	lcd_buf1[9] = tempa+0x30;
	lcd_buf1[10] = 0xc3;
	lcd_buf1[11] = 0xeb;   //秒
	lcd_buf1[12] = 0;   //结束标志
	
	lcd_buf2[0]=lcd_buf1[0];
	lcd_buf2[1]=lcd_buf1[1];
	lcd_buf2[2]=':';
	lcd_buf2[3]=lcd_buf1[4];
	lcd_buf2[4]=lcd_buf1[5];
	lcd_buf2[5]=':';
	lcd_buf2[6]=lcd_buf1[8];
	lcd_buf2[7]=lcd_buf1[9];
	lcd_buf2[8]=0;
	apoint_place_write(32,0,lcd_buf2,0,0x0fff);	
	
//   uchar  tempa;
//   uchar  lcd_buf[15],lcd_buf1[15];		//lcd_buf存年月日，lcd_buf1存时分秒
//   read_time();  //读取实时时间,放到time_buffer中
// 	lcd_buf[0] = '2';
// 	lcd_buf[1] = '0';
// 	tempa = (time_buff[0]>>4)&0x0f;
// 	lcd_buf[2] = tempa+0x30;		//转化为字符
// 	tempa = (time_buff[0]&0x0f);
// 	lcd_buf[3] = tempa + 0x30;
// 	lcd_buf[4] = 0xc4;
// 	lcd_buf[5] = 0xea;   //年
// 	tempa = (time_buff[1]>>4)&0x0f;
// 	lcd_buf[6] = tempa+0x30;
// 	tempa = time_buff[1]&0x0f;
// 	lcd_buf[7] = tempa+0x30;
// 	lcd_buf[8] = 0xd4;
// 	lcd_buf[9] = 0xc2;   //月
// 	tempa = (time_buff[2]>>4)&0x0f;
// 	lcd_buf[10] = tempa+0x30;
// 	tempa = time_buff[2]&0x0f;
// 	lcd_buf[11] = tempa+0x30;
// 	lcd_buf[12] = 0xc8;
// 	lcd_buf[13] = 0xd5;   //日
// 	lcd_buf[14] = 0;   //结束标志

// 	tempa = (time_buff[3]>>4)&0x0f;
// 	lcd_buf1[0] = tempa+0x30;
// 	tempa = time_buff[3]&0x0f;
// 	lcd_buf1[1] = tempa + 0x30;
// 	lcd_buf1[2] = 0xCA;
// 	lcd_buf1[3] = 0xB1;   //时
// 	tempa = (time_buff[4]>>4)&0x0f;
// 	lcd_buf1[4] = tempa+0x30;
// 	tempa = time_buff[4]&0x0f;
// 	lcd_buf1[5] = tempa+0x30;
// 	lcd_buf1[6] = 0xb7;
// 	lcd_buf1[7] = 0xd6;   //分
// 	tempa = (time_buff[5]>>4)&0x0f;
// 	lcd_buf1[8] = tempa+0x30;
// 	tempa = time_buff[5]&0x0f;
// 	lcd_buf1[9] = tempa+0x30;
// 	lcd_buf1[10] = 0xc3;
// 	lcd_buf1[11] = 0xeb;   //秒
// 	lcd_buf1[12] = 0;   //结束标志
// 	
// 	
// 	
// 	//void apoint_place_write(uchar s_column,uchar s_row,uchar *wr_sp,uint w_color,uint bk_color)
// 	apoint_place_write(0,1,lcd_buf,0,0xfff);  //年月日
// 	apoint_place_write(0,17,lcd_buf1,0,0xfff);  //时分秒
// 	apoint_place_write(36,56,"惠合科技",0,0x0fff);
// 	apoint_place_write(2,74,"电子智能钥匙",0,0x0fff);


}









/*
*
*	LCD 的管脚初始化
*
*/
void LCD_GPIO_Init(void)
{

	GPIO_InitTypeDef GPIO_InitStructure;
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC,ENABLE);
	
	//配置5个控制端口为输出
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB,&GPIO_InitStructure);
	
	//配置8个数据端口为输出
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | \
																	GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
	GPIO_Init(GPIOC,&GPIO_InitStructure);

}



// void Delayms(uint32_t t)
// {

// 	delay_ms(t);

// }

//写颜色，i为颜色高8位，j为颜色低8位
void write_data(int8_t i,int8_t j)
{

	Clr_Cs();
	Set_Rs();
	Set_Rd();
	

	GPIOC->ODR = ((GPIOC->ODR & 0xff00) | i );
	
	Clr_Wr();
	Set_Wr();
	
	
	GPIOC->ODR = ((GPIOC->ODR & 0xff00) | j );
	
	Clr_Wr();
	Set_Wr();
	Set_Cs();

}

//输出数据
void write_data8(int16_t b)
{


	Clr_Cs();
	Set_Rd();
	Set_Rs();
	//WR(0);
	
	GPIOC->ODR = ((GPIOC->ODR & 0xff00) | b );
	 
	Clr_Wr();
	delay_us(3);//有一个持续的低电平供给写数据
	Set_Wr();
	Clr_Rs();
	Set_Rd();
	Set_Cs();
	
}

//输出命令
void write_cmd(int16_t m)
{

	
	  Clr_Cs();
    Set_Rd();
    Clr_Rs();
    Set_Wr();
		GPIOC->ODR = ((GPIOC->ODR & 0xff00) | m );
    //OutPut_Data(m);
    Clr_Wr();   
	  delay_us(3);//有一个持续的低电平供给写数据
    Set_Wr(); 
    Clr_Rs();
    Set_Rd();    
    Set_Cs();

}




//驱动IC初始化
void Initial_ILI9163(void)
{
	
	// VCI=2.8V
//************* Reset LCD Driver ****************//
	
Set_Rst();
delay_ms(12); // Delay 1ms
Clr_Rst();
delay_us(110); // Delay 10ms // This delay time is necessary
Set_Rst();
delay_ms(219);
//************* Start Initial Sequence **********//
write_cmd(0x11); //Exit Sleep
delay_ms(44);
write_cmd(0x26); //Set Default Gamma
write_data8(0x04);
write_cmd(0xF2); //E0h & E1h Enable/Disable
write_data8(0x00);
write_cmd(0xB1);
write_data8(0x0C);
write_data8(0x14);
write_cmd(0xC0); //Set VRH1[4:0] & VC[2:0] for VCI1 & GVDD
write_data8(0x0C);
write_data8(0x05);
write_cmd(0xC1); //Set BT[2:0] for AVDD & VCL & VGH & VGL
write_data8(0x02);
write_cmd(0xC5); //Set VMH[6:0] & VML[6:0] for VOMH & VCOML
write_data8(0x32);
write_data8(0x3B);
write_cmd(0xC7);
write_data8(0x40);
write_cmd(0x2A); //Set Column Address
write_data8(0x00);
write_data8(0x00);
write_data8(0x00);
write_data8(0x7F);
write_cmd(0x2B); //Set Page Address
write_data8(0x00);
write_data8(0x00);
write_data8(0x00);
write_data8(0x9F);
write_cmd(0x36); //Set Scanning Direction
write_data8(0xC0);
write_cmd(0x3A); 
write_data8(0x55);
write_cmd(0x29); // Display On

}

void display_black(void)
{
	int j;
	int i;
	
	write_cmd(0x2A);       
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x7F);

   write_cmd(0x2B);       
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x9F);

   write_cmd(0x2C); //写RGB数据前的命令 
	for(i=0;i<128;i++)
	for(j=0;j<160;j++)
	write_data(0x00,0x00);
	delay_ms(10);
}


void display_white(void)
{
	
	int j;
	int i;

	write_cmd(0x2A);       
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x7F);

   write_cmd(0x2B);       
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x9F);

   write_cmd(0x2C);  //写RGB数据前的命令 
	for(i=0;i<128;i++)
	for(j=0;j<160;j++)
	write_data(0xff,0xff);
	delay_ms(10);
}


void display_red(void)
{
	int j;
	int i;

	write_cmd(0x2A);       
		write_data8(0x00);
		write_data8(0x00);
		write_data8(0x00);
		write_data8(0x7F);

		write_cmd(0x2B);       
		write_data8(0x00);
		write_data8(0x00);
		write_data8(0x00);
		write_data8(0x9F);

		write_cmd(0x2C);  //写RGB数据前的命令 
	for(i=0;i<128;i++)
	for(j=0;j<160;j++)
	write_data(0xf8,0x00);
	//delay_ms(10);
}


void display_green(void)
{
	int j;
	int i;

	write_cmd(0x2A);       
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x7F);

   write_cmd(0x2B);       
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x9F);

   write_cmd(0x2C);  
	for(i=0;i<128;i++)
	for(j=0;j<160;j++)
	write_data(0x07,0xe0);
	delay_ms(10);
}


void display_blue(void)
{
	int j;
	int i;

	write_cmd(0x2A);       
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x7F);

   write_cmd(0x2B);       
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x00);
   write_data8(0x9F);

   write_cmd(0x2C);  
	for(i=0;i<128;i++)
	for(j=0;j<160;j++)
	write_data(0x00,0x1f);
	delay_ms(10);
}


void LCD_Init(void)
{

	LCD_GPIO_Init();
	
	Set_Rst();
	delay_ms(67);
	Clr_Rst();
	delay_ms(131);
	Set_Rst();
	delay_ms(131);
	
  Initial_ILI9163();
	
	delay_ms(1500);
// 	display_red();
//   delay_ms(1500);
// 	
//   display_green();
//   delay_ms(1500);
	
//   display_white();
//   delay_ms(1500);
	
// 	display_blue();
//   delay_ms(1500);

}






